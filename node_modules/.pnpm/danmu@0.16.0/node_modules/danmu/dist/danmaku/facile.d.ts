import type { Track } from '../track';
import type { Container } from '../container';
import { createDanmakuLifeCycle } from '../lifeCycle';
import type {
  Speed,
  StyleKey,
  Position,
  MoveTimer,
  Direction,
  InfoRecord,
  Danmaku,
  DanmakuType,
  DanmakuPlugin,
  InternalStatuses,
} from '../types';
export type PluginSystem<D extends Danmaku<any>> = ReturnType<
  typeof createDanmakuLifeCycle<D>
>;
export interface FacileOptions<T> {
  data: T;
  rate: number;
  speed: Speed;
  duration: number;
  direction: Direction;
  container: Container;
  internalStatuses: InternalStatuses;
  delInTrack: (b: Danmaku<T>) => void;
}
export declare class FacileDanmaku<T> {
  _options: FacileOptions<T>;
  data: T;
  loops: number;
  isLoop: boolean;
  paused: boolean;
  moving: boolean;
  isEnded: boolean;
  isFixedDuration: boolean;
  rate: number;
  duration: number;
  recorder: InfoRecord;
  nextFrame: (fn: FrameRequestCallback) => void;
  type: DanmakuType;
  track: Track<T> | null;
  node: HTMLElement | null;
  moveTimer: MoveTimer | null;
  position: Position;
  pluginSystem: PluginSystem<Danmaku<T>>;
  protected _internalStatuses: InternalStatuses;
  protected _initData: {
    width: number;
    duration: number;
  };
  constructor(_options: FacileOptions<T>);
  /**
   * @internal
   */
  protected _delInTrack(): void;
  /**
   * @internal
   */
  _summaryWidth(): number;
  /**
   * @internal
   */
  _getMovePercent(): number;
  /**
   * @internal
   */
  _getMoveDistance(): number;
  /**
   * @internal
   */
  _getSpeed(): number;
  /**
   * @internal
   */
  _createNode(): void;
  /**
   * @internal
   */
  _appendNode(container: HTMLElement): void;
  /**
   * @internal
   */
  _removeNode(_flag?: Symbol): void;
  /**
   * @internal
   */
  _setOff(): Promise<void>;
  /**
   * @internal
   */
  _setStartStatus(): void;
  /**
   * @internal
   */
  _updatePosition(p: Partial<Position>): void;
  /**
   * @internal
   */
  _updateTrack(track: Track<T> | null): void;
  /**
   * @internal
   */
  _updateDuration(duration: number, updateInitData?: boolean): void;
  /**
   * @internal
   */
  _format(oldWidth: number, oldHeight: number, newTrack: Track<T>): void;
  /**
   * @internal
   */
  _reset(): void;
  get direction(): Direction;
  actualDuration(): number;
  setloop(): void;
  unloop(): void;
  getHeight(): number;
  getWidth(): number;
  pause(_flag?: Symbol): void;
  resume(_flag?: Symbol): void;
  hide(_flag?: Symbol): void;
  show(_flag?: Symbol): void;
  destroy(mark?: unknown): Promise<void>;
  setStyle<T extends StyleKey>(key: T, val: CSSStyleDeclaration[T]): void;
  remove(pluginName: string): void;
  use(
    plugin: DanmakuPlugin<T> | ((danmaku: this) => DanmakuPlugin<T>),
  ): Partial<
    Pick<
      import('hooks-plugin').Plugin<
        {
          hide: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          show: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          pause: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          resume: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          beforeMove: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          moved: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          createNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          appendNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          removeNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          beforeDestroy: import('hooks-plugin').AsyncHook<
            [Danmaku<T>, unknown],
            null
          >;
          destroyed: import('hooks-plugin').SyncHook<
            [Danmaku<T>, unknown],
            null,
            void
          >;
        },
        Record<string, unknown>
      >,
      'name' | 'version'
    >
  > & {
    hide?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    show?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    pause?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    resume?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    beforeMove?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    moved?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    createNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    appendNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    removeNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    beforeDestroy?:
      | import('hooks-plugin').Callback<
          [Danmaku<T>, unknown],
          null,
          import('hooks-plugin').CallbackReturnType<void>
        >
      | undefined;
    destroyed?:
      | import('hooks-plugin').Callback<[Danmaku<T>, unknown], null, void>
      | undefined;
  } & {
    name: string;
  };
}
