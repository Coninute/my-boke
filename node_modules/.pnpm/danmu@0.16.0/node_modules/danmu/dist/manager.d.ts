import { type Nullable } from 'aidly';
import { FacileDanmaku } from './danmaku/facile';
import type {
  Mode,
  Speed,
  Danmaku,
  DanmakuType,
  StyleKey,
  Direction,
  AreaOptions,
  EachCallback,
  FreezeOptions,
  FilterCallback,
  ManagerPlugin,
  ManagerOptions,
  PushOptions,
  PushFlexOptions,
} from './types';
export declare class Manager<
  T extends unknown,
  U extends Record<any, unknown> = Record<PropertyKey, unknown>,
> {
  options: ManagerOptions;
  version: string;
  nextFrame: (fn: FrameRequestCallback) => void;
  statuses: U;
  pluginSystem: import('hooks-plugin').PluginSystem<{
    $show: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $hide: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $pause: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $resume: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $beforeMove: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $moved: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
    $createNode: import('hooks-plugin').SyncHook<
      [Danmaku<T>, HTMLElement],
      null,
      void
    >;
    $appendNode: import('hooks-plugin').SyncHook<
      [Danmaku<T>, HTMLElement],
      null,
      void
    >;
    $removeNode: import('hooks-plugin').SyncHook<
      [Danmaku<T>, HTMLElement],
      null,
      void
    >;
    $beforeDestroy: import('hooks-plugin').AsyncHook<
      [Danmaku<T>, unknown],
      null
    >;
    $destroyed: import('hooks-plugin').SyncHook<
      [Danmaku<T>, unknown],
      null,
      void
    >;
    format: import('hooks-plugin').SyncHook<[], null, void>;
    start: import('hooks-plugin').SyncHook<[], null, void>;
    stop: import('hooks-plugin').SyncHook<[], null, void>;
    show: import('hooks-plugin').SyncHook<[], null, void>;
    hide: import('hooks-plugin').SyncHook<[], null, void>;
    freeze: import('hooks-plugin').SyncHook<[], null, void>;
    unfreeze: import('hooks-plugin').SyncHook<[], null, void>;
    finished: import('hooks-plugin').SyncHook<[], null, void>;
    clear: import('hooks-plugin').SyncHook<[Nullable<DanmakuType>], null, void>;
    mount: import('hooks-plugin').SyncHook<[HTMLElement], null, void>;
    unmount: import('hooks-plugin').SyncHook<[HTMLElement | null], null, void>;
    init: import('hooks-plugin').SyncHook<
      [manager: Manager<T, Record<PropertyKey, unknown>>],
      null,
      void
    >;
    limitWarning: import('hooks-plugin').SyncHook<
      [DanmakuType, number],
      null,
      void
    >;
    push: import('hooks-plugin').SyncHook<
      [T | Danmaku<T>, DanmakuType, boolean],
      null,
      void
    >;
    render: import('hooks-plugin').SyncHook<[DanmakuType], null, void>;
    updateOptions: import('hooks-plugin').SyncHook<
      [Partial<ManagerOptions>, Nullable<keyof ManagerOptions>],
      null,
      void
    >;
    willRender: import('hooks-plugin').SyncWaterfallHook<
      {
        type: DanmakuType;
        prevent: boolean;
        danmaku: Danmaku<T>;
        trackIndex: number | null;
      },
      null
    >;
  }>;
  private _engine;
  private _renderTimer;
  private _internalStatuses;
  constructor(options: ManagerOptions);
  /**
   * @internal
   */
  private _mergeOptions;
  /**
   * @internal
   */
  private _setViewStatus;
  get container(): import('./container').Container;
  get trackCount(): number;
  len(): {
    stash: number;
    flexible: number;
    view: number;
    all: number;
  };
  isShow(): boolean;
  isFreeze(): boolean;
  isPlaying(): boolean;
  isDanmaku(dm: unknown): dm is Danmaku<T>;
  each(fn: EachCallback<T>): void;
  asyncEach(fn: EachCallback<T>): Promise<void | undefined>;
  getTrack(i: number): import('./track').Track<T>;
  freeze({ preventEvents }?: FreezeOptions): void;
  unfreeze({ preventEvents }?: FreezeOptions): void;
  format(): void;
  mount(
    parentNode?: HTMLElement | string,
    {
      clear,
    }?: {
      clear?: boolean;
    },
  ): void;
  unmount(): void;
  clear(type?: Nullable<DanmakuType>, _flag?: Symbol): void;
  updateOptions(
    newOptions: Partial<ManagerOptions>,
    key?: Nullable<keyof ManagerOptions>,
  ): void;
  startPlaying(_flag?: Symbol): void;
  stopPlaying(_flag?: Symbol): void;
  show(filter?: FilterCallback<T>): Promise<void>;
  hide(filter?: FilterCallback<T>): Promise<void>;
  canPush(type: DanmakuType): boolean;
  unshift(data: T | FacileDanmaku<T>, options?: PushOptions<T>): boolean;
  push(
    data: T | FacileDanmaku<T>,
    options?: PushOptions<T>,
    _unshift?: Symbol,
  ): boolean;
  pushFlexibleDanmaku(data: T, options: PushFlexOptions<T>): boolean;
  updateOccludedUrl(
    url?: string | null,
    el?: HTMLElement | string | null,
  ): void;
  render(): void;
  remove(pluginName: string): void;
  use(plugin: ManagerPlugin<T> | ((m: this) => ManagerPlugin<T>)): Partial<
    Pick<
      import('hooks-plugin').Plugin<
        {
          $show: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          $hide: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          $pause: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          $resume: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          $beforeMove: import('hooks-plugin').SyncHook<
            [Danmaku<T>],
            null,
            void
          >;
          $moved: import('hooks-plugin').SyncHook<[Danmaku<T>], null, void>;
          $createNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          $appendNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          $removeNode: import('hooks-plugin').SyncHook<
            [Danmaku<T>, HTMLElement],
            null,
            void
          >;
          $beforeDestroy: import('hooks-plugin').AsyncHook<
            [Danmaku<T>, unknown],
            null
          >;
          $destroyed: import('hooks-plugin').SyncHook<
            [Danmaku<T>, unknown],
            null,
            void
          >;
          format: import('hooks-plugin').SyncHook<[], null, void>;
          start: import('hooks-plugin').SyncHook<[], null, void>;
          stop: import('hooks-plugin').SyncHook<[], null, void>;
          show: import('hooks-plugin').SyncHook<[], null, void>;
          hide: import('hooks-plugin').SyncHook<[], null, void>;
          freeze: import('hooks-plugin').SyncHook<[], null, void>;
          unfreeze: import('hooks-plugin').SyncHook<[], null, void>;
          finished: import('hooks-plugin').SyncHook<[], null, void>;
          clear: import('hooks-plugin').SyncHook<
            [Nullable<DanmakuType>],
            null,
            void
          >;
          mount: import('hooks-plugin').SyncHook<[HTMLElement], null, void>;
          unmount: import('hooks-plugin').SyncHook<
            [HTMLElement | null],
            null,
            void
          >;
          init: import('hooks-plugin').SyncHook<
            [manager: Manager<T, Record<PropertyKey, unknown>>],
            null,
            void
          >;
          limitWarning: import('hooks-plugin').SyncHook<
            [DanmakuType, number],
            null,
            void
          >;
          push: import('hooks-plugin').SyncHook<
            [T | Danmaku<T>, DanmakuType, boolean],
            null,
            void
          >;
          render: import('hooks-plugin').SyncHook<[DanmakuType], null, void>;
          updateOptions: import('hooks-plugin').SyncHook<
            [Partial<ManagerOptions>, Nullable<keyof ManagerOptions>],
            null,
            void
          >;
          willRender: import('hooks-plugin').SyncWaterfallHook<
            {
              type: DanmakuType;
              prevent: boolean;
              danmaku: Danmaku<T>;
              trackIndex: number | null;
            },
            null
          >;
        },
        Record<string, unknown>
      >,
      'name' | 'version'
    >
  > & {
    $show?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $hide?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $pause?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $resume?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $beforeMove?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $moved?:
      | import('hooks-plugin').Callback<[Danmaku<T>], null, void>
      | undefined;
    $createNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    $appendNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    $removeNode?:
      | import('hooks-plugin').Callback<[Danmaku<T>, HTMLElement], null, void>
      | undefined;
    $beforeDestroy?:
      | import('hooks-plugin').Callback<
          [Danmaku<T>, unknown],
          null,
          import('hooks-plugin').CallbackReturnType<void>
        >
      | undefined;
    $destroyed?:
      | import('hooks-plugin').Callback<[Danmaku<T>, unknown], null, void>
      | undefined;
    format?: import('hooks-plugin').Callback<[], null, void> | undefined;
    start?: import('hooks-plugin').Callback<[], null, void> | undefined;
    stop?: import('hooks-plugin').Callback<[], null, void> | undefined;
    show?: import('hooks-plugin').Callback<[], null, void> | undefined;
    hide?: import('hooks-plugin').Callback<[], null, void> | undefined;
    freeze?: import('hooks-plugin').Callback<[], null, void> | undefined;
    unfreeze?: import('hooks-plugin').Callback<[], null, void> | undefined;
    finished?: import('hooks-plugin').Callback<[], null, void> | undefined;
    clear?:
      | import('hooks-plugin').Callback<[Nullable<DanmakuType>], null, void>
      | undefined;
    mount?:
      | import('hooks-plugin').Callback<[HTMLElement], null, void>
      | undefined;
    unmount?:
      | import('hooks-plugin').Callback<[HTMLElement | null], null, void>
      | undefined;
    init?:
      | import('hooks-plugin').Callback<
          [manager: Manager<T, Record<PropertyKey, unknown>>],
          null,
          void
        >
      | undefined;
    limitWarning?:
      | import('hooks-plugin').Callback<[DanmakuType, number], null, void>
      | undefined;
    push?:
      | import('hooks-plugin').Callback<
          [T | Danmaku<T>, DanmakuType, boolean],
          null,
          void
        >
      | undefined;
    render?:
      | import('hooks-plugin').Callback<[DanmakuType], null, void>
      | undefined;
    updateOptions?:
      | import('hooks-plugin').Callback<
          [Partial<ManagerOptions>, Nullable<keyof ManagerOptions>],
          null,
          void
        >
      | undefined;
    willRender?:
      | import('hooks-plugin').Callback<
          [
            {
              type: DanmakuType;
              prevent: boolean;
              danmaku: Danmaku<T>;
              trackIndex: number | null;
            },
          ],
          null,
          {
            type: DanmakuType;
            prevent: boolean;
            danmaku: Danmaku<T>;
            trackIndex: number | null;
          }
        >
      | undefined;
  } & {
    name: string;
  };
  setStyle<T extends StyleKey>(key: T, val: CSSStyleDeclaration[T]): void;
  setOpacity(opacity: number | string): void;
  setArea(size: AreaOptions): void;
  setGap(gap: number | string): void;
  setMode(mode: Mode): void;
  setSpeed(speed?: Speed): void;
  setRate(rate: number): void;
  setInterval(interval: number): void;
  setTrackHeight(trackHeight: number | string): void;
  setDurationRange(durationRange: [number, number]): void;
  setDirection(direction: Exclude<Direction, 'none'>): void;
  setLimits({ view, stash }: { view?: number; stash?: number }): void;
}
