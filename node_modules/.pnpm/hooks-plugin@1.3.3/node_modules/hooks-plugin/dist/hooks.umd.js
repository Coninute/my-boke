(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports)
    : typeof define === 'function' && define.amd
    ? define(['exports'], factory)
    : ((global =
        typeof globalThis !== 'undefined' ? globalThis : global || self),
      factory((global.HooksPlugin = {})));
})(this, function (exports) {
  'use strict';

  const objectToString = Object.prototype.toString;
  const isObject = (v) => {
    return v !== null && typeof v === 'object';
  };
  const isPromiseLike = (v) => {
    return isObject(v) && typeof v.then === 'function';
  };
  const isPlainObject = (v) => {
    return objectToString.call(v) === '[object Object]';
  };
  const isPrimitiveValue = (v) => {
    return (
      typeof v === 'number' ||
      typeof v === 'bigint' ||
      typeof v === 'string' ||
      typeof v === 'symbol' ||
      typeof v === 'boolean' ||
      v === undefined ||
      v === null
    );
  };
  let byteToHex;
  const unsafeStringify = (arr) => {
    if (!byteToHex) {
      byteToHex = [];
      for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 0x100).toString(16).slice(1));
      }
    }
    return (
      byteToHex[arr[0]] +
      byteToHex[arr[1]] +
      byteToHex[arr[2]] +
      byteToHex[arr[3]] +
      '-' +
      byteToHex[arr[4]] +
      byteToHex[arr[5]] +
      '-' +
      byteToHex[arr[6]] +
      byteToHex[arr[7]] +
      '-' +
      byteToHex[arr[8]] +
      byteToHex[arr[9]] +
      '-' +
      byteToHex[arr[10]] +
      byteToHex[arr[11]] +
      byteToHex[arr[12]] +
      byteToHex[arr[13]] +
      byteToHex[arr[14]] +
      byteToHex[arr[15]]
    ).toLowerCase();
  };
  let poolPtr;
  let rnds8Pool;
  const rng = () => {
    if (!rnds8Pool) {
      rnds8Pool = new Uint8Array(256);
      poolPtr = rnds8Pool.length;
    }
    if (poolPtr > 256 - 16) {
      for (let i = 0; i < 256; i++) {
        rnds8Pool[i] = Math.floor(Math.random() * 256);
      }
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, (poolPtr += 16));
  };
  const uuid = () => {
    const rnds = rng();
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return unsafeStringify(rnds);
  };
  function assert(condition, error) {
    if (!condition) throw new Error(error);
  }
  const hasOwn = (obj, key) => {
    return Object.hasOwnProperty.call(obj, key);
  };
  const pick = (val, keys, omitUndefined = false) => {
    return keys.reduce((n, k) => {
      if (k in val) {
        if (!omitUndefined || val[k] !== undefined) {
          n[k] = val[k];
        }
      }
      return n;
    }, {});
  };
  const omit = (val, keys) => {
    return Object.keys(val).reduce((n, k) => {
      if (!keys.includes(k)) {
        n[k] = val[k];
      }
      return n;
    }, {});
  };

  const INTERNAL = Symbol('internal_hooks');
  const INVALID_VALUE = Symbol('invalid_condition_value');
  const PERFORMANCE_PLUGIN_PREFIX = '__performance_monitor__';
  const isBrowser = typeof window !== 'undefined';
  let taskId = 1;
  const createTaskId = () => taskId++;
  let monitorTaskId = 1;
  const createMonitorTaskId = () => monitorTaskId++;
  let monitorPluginId = 1;
  const createMonitorPluginId = () => monitorPluginId++;
  const checkReturnData = (originData, returnData) => {
    if (!isPlainObject(returnData)) return false;
    if (originData !== returnData) {
      for (const key in originData) {
        if (!(key in returnData)) {
          return false;
        }
      }
    }
    return true;
  };
  const getTargetInArgs = (key, args) => {
    let target = args;
    const parts = key.split('.');
    for (let i = 0, l = parts.length; i < l; i++) {
      if (!target) return INVALID_VALUE;
      let p = parts[i];
      if (p.startsWith('[') && p.endsWith(']')) {
        p = Number(p.slice(1, -1));
      }
      target = target[p];
    }
    return target;
  };

  class SyncHook {
    _locked;
    context;
    type;
    listeners = new Set();
    tags = new WeakMap();
    errors = new Set();
    before;
    after;
    // Only `context` is allowed to be passed in from outside
    constructor(context, _type = 'SyncHook', _internal) {
      this.type = _type;
      this._locked = false;
      this.context = typeof context === 'undefined' ? null : context;
      // `before` and `after` hooks should not call other `before` and `after` hooks recursively,
      // as it can lead to infinite loops.
      if (_internal !== INTERNAL) {
        this.before = new SyncHook(null, 'SyncHook', INTERNAL);
        this.after = new SyncHook(null, 'SyncHook', INTERNAL);
      }
    }
    /**
     * @internal
     */
    _emitError(error, hook, tag) {
      if (this.errors.size > 0) {
        this.errors.forEach((fn) =>
          fn({
            tag,
            hook,
            error,
            type: this.type,
          }),
        );
      } else {
        throw error;
      }
    }
    /**
     * Determine whether there is an executable callback function.
     */
    isEmpty() {
      return this.listeners.size === 0;
    }
    /**
     * By locking the current hook, you will no longer be able to add or remove callback functions from it.
     */
    lock() {
      this._locked = true;
      if (this.before) this.before.lock();
      if (this.after) this.after.lock();
      return this;
    }
    /**
     * Unlock the current hook.
     */
    unlock() {
      this._locked = false;
      if (this.before) this.before.unlock();
      if (this.after) this.after.unlock();
      return this;
    }
    on(tag, fn) {
      assert(!this._locked, 'The current hook is now locked.');
      if (typeof tag === 'function') {
        fn = tag;
        tag = '';
      }
      assert(typeof fn === 'function', `Invalid parameter in "${this.type}".`);
      if (tag && typeof tag === 'string') {
        this.tags.set(fn, tag);
      }
      this.listeners.add(fn);
      return this;
    }
    once(tag, fn) {
      if (typeof tag === 'function') {
        fn = tag;
        tag = '';
      }
      const self = this;
      this.on(tag, function wrapper(...args) {
        self.remove(wrapper, INTERNAL);
        return fn.apply(this, args);
      });
      return this;
    }
    /**
     * trigger hooks.
     */
    emit(...data) {
      if (this.listeners.size > 0) {
        const id = createTaskId();
        let map = null;
        if (!this.after?.isEmpty()) {
          map = Object.create(null);
        }
        this.before?.emit(id, this.type, this.context, data);
        this.listeners.forEach((fn) => {
          const tag = this.tags.get(fn);
          if (map && tag) {
            map[tag] = Date.now();
          }
          const record = () => {
            if (map && tag) {
              map[tag] = Date.now() - map[tag];
            }
          };
          try {
            fn.apply(this.context, data);
            record();
          } catch (e) {
            record();
            this._emitError(e, fn, tag);
          }
        });
        // The data being mapped will only be meaningful if `after` is not empty.
        this.after?.emit(id, this.type, this.context, data, map);
      }
    }
    /**
     * Remove all hooks.
     */
    remove(fn, _flag) {
      if (_flag !== INTERNAL) {
        assert(!this._locked, 'The current hook is now locked.');
      }
      this.listeners.delete(fn);
      return this;
    }
    /**
     * Remove a specific hook.
     */
    removeAll() {
      assert(!this._locked, 'The current hook is now locked.');
      this.listeners.clear();
      return this;
    }
    /**
     * Listen for errors when the hook is running.
     */
    listenError(fn) {
      assert(!this._locked, 'The current hook is now locked.');
      this.errors.add(fn);
    }
    /**
     *  Clone a clean instance.
     */
    clone() {
      return new this.constructor(
        this.context,
        this.type,
        this.before ? null : INTERNAL,
      );
    }
  }

  class AsyncHook extends SyncHook {
    constructor(context) {
      super(context, 'AsyncHook');
    }
    emit(...data) {
      let id;
      let result;
      const ls = Array.from(this.listeners);
      let map = null;
      if (ls.length > 0) {
        id = createTaskId();
        if (!this.after?.isEmpty()) {
          map = Object.create(null);
        }
        this.before?.emit(id, this.type, this.context, data);
        let i = 0;
        const call = (prev) => {
          if (prev === false) {
            return false; // Abort process
          } else if (i < ls.length) {
            let res;
            const fn = ls[i++];
            const tag = this.tags.get(fn);
            if (map && tag) {
              map[tag] = Date.now();
            }
            const record = () => {
              if (map && tag) {
                map[tag] = Date.now() - map[tag];
              }
            };
            try {
              res = fn.apply(this.context, data);
            } catch (e) {
              // If there is an error in the function call,
              // there is no need to monitor the result of the promise.
              record();
              this._emitError(e, fn, tag);
              return call(prev);
            }
            return Promise.resolve(res)
              .finally(record)
              .then(call)
              .catch((e) => {
                this._emitError(e, fn, tag);
                return call(prev);
              });
          } else {
            return prev;
          }
        };
        result = call();
      }
      return Promise.resolve(result).then((result) => {
        if (ls.length > 0) {
          // The data being mapped will only be meaningful if `after` is not empty.
          this.after?.emit(id, this.type, this.context, data, map);
        }
        return result;
      });
    }
  }

  class SyncWaterfallHook extends SyncHook {
    constructor(context) {
      super(context, 'SyncWaterfallHook');
    }
    emit(data) {
      assert(
        isPlainObject(data),
        `"${this.type}" hook response data must be an object.`,
      );
      if (this.listeners.size > 0) {
        const id = createTaskId();
        let map = null;
        if (!this.after?.isEmpty()) {
          map = Object.create(null);
        }
        this.before?.emit(id, this.type, this.context, [data]);
        for (const fn of this.listeners) {
          const tag = this.tags.get(fn);
          if (map && tag) {
            map[tag] = Date.now();
          }
          const record = () => {
            if (map && tag) {
              map[tag] = Date.now() - map[tag];
            }
          };
          try {
            const tempData = fn.call(this.context, data);
            assert(
              checkReturnData(data, tempData),
              `The return value of hook "${this.type}" is incorrect.`,
            );
            data = tempData;
            record();
          } catch (e) {
            record();
            this._emitError(e, fn, tag);
          }
        }
        this.after?.emit(id, this.type, this.context, [data], map);
      }
      return data;
    }
  }

  class AsyncParallelHook extends SyncHook {
    constructor(context) {
      super(context, 'AsyncParallelHook');
    }
    emit(...data) {
      let id;
      let map = null;
      // Disclaimer in advance, `listeners` may change
      const size = this.listeners.size;
      const taskList = [];
      if (size > 0) {
        id = createTaskId();
        if (!this.after?.isEmpty()) {
          map = Object.create(null);
        }
        this.before?.emit(id, this.type, this.context, data);
        for (const fn of this.listeners) {
          taskList.push(
            Promise.resolve().then(() => {
              const tag = this.tags.get(fn);
              if (map && tag) {
                map[tag] = Date.now();
              }
              const record = () => {
                if (map && tag) {
                  map[tag] = Date.now() - map[tag];
                }
              };
              try {
                const res = fn.apply(this.context, data);
                if (isPromiseLike(res)) {
                  // `Thenable` may not provide `catch` method,
                  // It needs to be wrapped with a promise.
                  return Promise.resolve(res).catch((e) => {
                    record();
                    this._emitError(e, fn, tag);
                    return null;
                  });
                } else {
                  record();
                  return res;
                }
              } catch (e) {
                this._emitError(e, fn, tag);
                return null;
              }
            }),
          );
        }
      }
      return Promise.all(taskList).then(() => {
        if (size > 0) {
          this.after?.emit(id, this.type, this.context, data, map);
        }
      });
    }
  }

  class AsyncWaterfallHook extends SyncHook {
    constructor(context) {
      super(context, 'AsyncWaterfallHook');
    }
    emit(data) {
      assert(
        isPlainObject(data),
        `"${this.type}" hook response data must be an object.`,
      );
      let i = 0;
      let id;
      let map = null;
      const ls = Array.from(this.listeners);
      if (ls.length > 0) {
        id = createTaskId();
        if (!this.after?.isEmpty()) {
          map = Object.create(null);
        }
        this.before?.emit(id, this.type, this.context, [data]);
        const call = (prev) => {
          if (prev === false) {
            return false;
          } else {
            assert(
              checkReturnData(data, prev),
              `The return value of hook "${this.type}" is incorrect.`,
            );
            data = prev;
            if (i < ls.length) {
              let res;
              const fn = ls[i++];
              const tag = this.tags.get(fn);
              if (map && tag) {
                map[tag] = Date.now();
              }
              const record = () => {
                if (map && tag) {
                  map[tag] = Date.now() - map[tag];
                }
              };
              try {
                res = fn.call(this.context, prev);
              } catch (e) {
                // If there is an error in the function call,
                // there is no need to monitor the result of the promise.
                record();
                this._emitError(e, fn, tag);
                return call(prev);
              }
              return Promise.resolve(res)
                .finally(record)
                .then(call)
                .catch((e) => {
                  this._emitError(e, fn, tag);
                  return call(prev);
                });
            }
          }
          return data;
        };
        return Promise.resolve(call(data)).then((data) => {
          this.after?.emit(id, this.type, this.context, [data], map);
          return data;
        });
      } else {
        return Promise.resolve(data);
      }
    }
  }

  function createPerformance(plSys, defaultCondition) {
    let hooks = {};
    let closed = false;
    const pluginName = `${PERFORMANCE_PLUGIN_PREFIX}${createMonitorPluginId()}`;
    // If value is equivalent, it represents an event bus
    // Note (need to guide users):
    //  The `value` is recorded here,
    //  but the value is unknown and there may be a memory leak.
    //  The user needs to manually close the performance monitoring to clear it.
    let records1 = new Map();
    let records2 = Object.create(null);
    // Some information about each time a monitor is created is recorded here.
    let monitorTask = Object.create(null);
    const findCondition = (key, conditions) => {
      if (!conditions) return defaultCondition;
      return conditions[key] || defaultCondition;
    };
    for (const key in plSys.lifecycle) {
      hooks[key] = function (...args) {
        let value;
        for (const id in monitorTask) {
          const [sk, ek, conditions, hook] = monitorTask[id];
          const condition = findCondition(key, conditions);
          if (key === ek) {
            value = getTargetInArgs(condition, args);
            if (value !== INVALID_VALUE) {
              const prevObj = isPrimitiveValue(value)
                ? records2[value]
                : records1.get(value);
              if (prevObj) {
                const prevTime = prevObj[`${id}_${sk}`];
                if (typeof prevTime === 'number') {
                  hook.emit({
                    endArgs: args,
                    endContext: this,
                    events: [sk, ek],
                    equalValue: value,
                    time: Date.now() - prevTime,
                  });
                }
              }
            }
          }
          if (key === sk) {
            value = value || getTargetInArgs(condition, args);
            if (value !== INVALID_VALUE) {
              let obj;
              const k = `${id}_${sk}`;
              const t = Date.now();
              if (isPrimitiveValue(value)) {
                obj = records2[value];
                if (!obj) {
                  obj = Object.create(null);
                  records2[value] = obj;
                }
              } else {
                obj = records1.get(value);
                if (!obj) {
                  obj = Object.create(null);
                  records1.set(value, obj);
                }
              }
              obj[k] = t;
            }
          }
        }
      };
    }
    plSys.use({
      hooks,
      name: pluginName,
    });
    return {
      /**
       * Turn off performance monitoring.
       */
      close() {
        if (!closed) {
          closed = true;
          records1.clear();
          records2 = Object.create(null);
          monitorTask = Object.create(null);
          this._taskHooks.hs.forEach((hook) => hook.removeAll());
          this._taskHooks.hs.clear();
          plSys.remove(pluginName);
        }
      },
      /**
       * Add new observation task.
       */
      monitor(sk, ek, conditions) {
        assert(
          !closed,
          'Unable to add tasks to a closed performance observer.',
        );
        const id = createMonitorTaskId();
        const hook = new SyncHook();
        const task = [sk, ek, conditions, hook];
        monitorTask[id] = task;
        this._taskHooks.add(hook);
        return hook;
      },
      _taskHooks: {
        hs: new Set(),
        watch: new Set(),
        add(hook) {
          this.hs.add(hook);
          this.watch.forEach((fn) => fn(hook));
        },
      },
    };
  }

  // If there is user defined performance data,
  // it should also be printed here.
  function logPerformance(p, performanceReceiver, tag) {
    const _tag = `[${tag || 'debug'}_performance]`;
    const fn = (e) => {
      if (typeof performanceReceiver === 'function') {
        performanceReceiver({ tag, e });
      } else {
        console.log(
          `${_tag}(${e.events[0]} -> ${e.events[1]}): ${e.time}`,
          e.endArgs,
          e.endContext,
        );
      }
    };
    p._taskHooks.watch.add((hook) => hook.on(fn));
    p._taskHooks.hs.forEach((hook) => hook.on(fn));
  }
  function createDebugger(plSys, options) {
    let {
      tag,
      group,
      filter,
      receiver,
      listenError,
      logPluginTime,
      errorReceiver,
      performance,
      performanceReceiver,
    } = options;
    let unsubscribeError = null;
    let map = Object.create(null);
    const _tag = `[${tag || 'debug'}]: `;
    if (!('group' in options)) group = isBrowser;
    if (!('listenError' in options)) listenError = true;
    if (!('logPluginTime' in options)) logPluginTime = true;
    if (performance) logPerformance(performance, performanceReceiver, tag);
    const prefix = (e) => {
      let p = `${_tag}${e.name}_${e.id}(t, args, ctx`;
      p += logPluginTime ? ', pt)' : ')';
      return p;
    };
    const unsubscribeBefore = plSys.beforeEach((e) => {
      map[e.id] = { t: Date.now() };
      if (typeof receiver !== 'function') {
        console.time(prefix(e));
        if (group) console.groupCollapsed(e.name);
      }
    });
    const unsubscribeAfter = plSys.afterEach((e) => {
      let t = null;
      if (typeof filter === 'string') {
        if (e.name.startsWith(filter)) {
          if (group) console.groupEnd();
          return;
        }
      } else if (typeof filter === 'function') {
        t = Date.now() - map[e.id].t;
        if (filter({ e, tag, time: t })) {
          if (group) console.groupEnd();
          return;
        }
      }
      if (typeof receiver === 'function') {
        if (t === null) {
          t = Date.now() - map[e.id].t;
        }
        receiver({ e, tag, time: t });
      } else {
        console.timeLog(
          prefix(e),
          e.args,
          e.context,
          logPluginTime ? e.pluginExecTime : '',
        );
        if (group) console.groupEnd();
      }
    });
    if (listenError) {
      unsubscribeError = plSys.listenError((e) => {
        if (typeof errorReceiver === 'function') {
          errorReceiver(e);
        } else {
          console.error(
            `[${tag}]: The error originated from "${e.tag}.${e.name}(${e.type})".\n`,
            `The hook function is: ${String(e.hook)}\n\n`,
            e.error,
          );
        }
      });
    }
    return () => {
      unsubscribeBefore();
      unsubscribeAfter();
      if (unsubscribeError) {
        unsubscribeError();
      }
      map = Object.create(null);
      if (performance) {
        performance.close();
      }
    };
  }

  const HOOKS = {
    SyncHook,
    AsyncHook,
    AsyncParallelHook,
    SyncWaterfallHook,
    AsyncWaterfallHook,
  };
  class PluginSystem {
    _locked;
    _debugs;
    _performances;
    _lockListenSet;
    lifecycle;
    plugins;
    constructor(lifecycle) {
      this._locked = false;
      this._debugs = new Set();
      this._performances = new Set();
      this._lockListenSet = new Set();
      this.plugins = Object.create(null);
      this.lifecycle = lifecycle || Object.create(null);
    }
    /**
     * @internal
     */
    _onEmitLifeHook(type, fn) {
      assert(
        !this._locked,
        `The plugin system is locked and cannot add "${type}" hook.`,
      );
      let map = Object.create(null);
      for (const key in this.lifecycle) {
        map[key] = (id, type, context, args, map) => {
          // Disallow deleting `id` as it may cause confusion.
          fn(
            Object.freeze({
              id,
              type,
              args,
              context,
              name: key,
              pluginExecTime: map,
            }),
          );
        };
        this.lifecycle[key][type].on(map[key]);
      }
      return () => {
        for (const key in this.lifecycle) {
          this.lifecycle[key][type].remove(map[key]);
        }
        map = Object.create(null);
      };
    }
    /**
     * Observing the changes in `lock`.
     */
    listenLock(fn) {
      this._lockListenSet.add(fn);
    }
    /**
     * Lock the plugin system. After locking, you will not be able to register and uninstall plugins.
     */
    lock() {
      this._locked = true;
      for (const key in this.lifecycle) {
        this.lifecycle[key].lock();
      }
      if (this._lockListenSet.size > 0) {
        this._lockListenSet.forEach((fn) => fn(true));
      }
    }
    /**
     * Unlock the plugin system. After unlocking, you can re-register and uninstall plugins.
     */
    unlock() {
      this._locked = false;
      for (const key in this.lifecycle) {
        this.lifecycle[key].unlock();
      }
      if (this._lockListenSet.size > 0) {
        this._lockListenSet.forEach((fn) => fn(false));
      }
    }
    /**
     * Registers a (sync) callback to be called before each hook is being called.
     */
    beforeEach(fn) {
      return this._onEmitLifeHook('before', fn);
    }
    /**
     * Registers a (sync) callback to be called after each hook is being called.
     */
    afterEach(fn) {
      return this._onEmitLifeHook('after', fn);
    }
    /**
     * Monitor elapsed time between hooks.
     */
    performance(defaultCondition) {
      assert(
        !this._locked,
        'The plugin system is locked and performance cannot be monitored.',
      );
      assert(
        defaultCondition && typeof defaultCondition === 'string',
        'A judgment `conditions` is required to use `performance`.',
      );
      const obj = createPerformance(this, defaultCondition);
      const { close } = obj;
      const fn = () => {
        assert(
          !this._locked,
          'The plugin system is locked and removal operations are not allowed.',
        );
        this._performances.delete(fn);
        return close.call(obj);
      };
      obj.close = fn;
      this._performances.add(fn);
      return obj;
    }
    /**
     * Remove all performance monitoring.
     */
    removeAllPerformance() {
      assert(
        !this._locked,
        'The plugin system is locked and removal operations are not allowed.',
      );
      this._performances.forEach((fn) => fn());
    }
    /**
     * Add debugger.
     */
    debug(options = {}) {
      assert(
        !this._locked,
        'The plugin system is locked and the debugger cannot be added.',
      );
      const close = createDebugger(this, options);
      const fn = () => {
        assert(
          !this._locked,
          'The plugin system is locked and removal operations are not allowed.',
        );
        this._debugs.delete(fn);
        close();
      };
      this._debugs.add(fn);
      return fn;
    }
    /**
     * Remove all debug instances.
     */
    removeAllDebug() {
      assert(
        !this._locked,
        'The plugin system is locked and removal operations are not allowed.',
      );
      this._debugs.forEach((fn) => fn());
    }
    /**
     * Get the `apis` of a plugin.
     */
    getPluginApis(pluginName) {
      return this.plugins[pluginName].apis;
    }
    /**
     * Listen for errors when the hook is running.
     */
    listenError(fn) {
      assert(
        !this._locked,
        'The plugin system is locked and cannot listen for errors.',
      );
      const map = Object.create(null);
      for (const key in this.lifecycle) {
        map[key] = (e) => {
          fn(Object.assign(e, { name: key }));
        };
        this.lifecycle[key].listenError(map[key]);
      }
      return () => {
        assert(
          !this._locked,
          'The plugin system is locked and the listening error cannot be removed.',
        );
        for (const key in this.lifecycle) {
          this.lifecycle[key].errors.delete(map[key]);
        }
      };
    }
    useRefine(plugin) {
      return this.use(plugin, INTERNAL);
    }
    use(plugin, _flag) {
      assert(
        !this._locked,
        `The plugin system is locked and new plugins cannot be added${
          plugin.name ? `(${plugin.name})` : ''
        }.`,
      );
      if (typeof plugin === 'function') plugin = plugin(this);
      assert(isPlainObject(plugin), 'Invalid plugin configuration.');
      // Simplified version of the input
      if (_flag === INTERNAL) {
        plugin = {
          version: plugin.version,
          name: plugin.name || uuid(),
          hooks: omit(plugin, ['name', 'version']),
        };
      }
      const { name } = plugin;
      assert(name && typeof name === 'string', 'Plugin must provide a "name".');
      assert(!this.isUsed(name), `Repeat to register plugin hooks "${name}".`);
      const register = (obj, once) => {
        if (obj) {
          for (const key in obj) {
            assert(
              hasOwn(this.lifecycle, key),
              `"${key}" hook is not defined in plugin "${name}".`,
            );
            // The loss of built-in plugins for performance statistics is negligible
            const tag = name.startsWith(PERFORMANCE_PLUGIN_PREFIX) ? '' : name;
            if (once) {
              this.lifecycle[key].once(tag, obj[key]);
            } else {
              this.lifecycle[key].on(tag, obj[key]);
            }
          }
        }
      };
      register(plugin.hooks, false);
      register(plugin.onceHooks, true);
      this.plugins[name] = plugin;
      return plugin;
    }
    /**
     * Remove plugin.
     */
    remove(pluginName) {
      assert(
        !this._locked,
        'The plugin system has been locked and the plugin cannot be cleared.',
      );
      assert(pluginName, 'Must provide a "name".');
      if (hasOwn(this.plugins, pluginName)) {
        const plugin = this.plugins[pluginName];
        const rm = (obj) => {
          if (obj) {
            for (const key in obj) {
              this.lifecycle[key].remove(obj[key]);
            }
          }
        };
        rm(plugin.hooks);
        rm(plugin.onceHooks);
        delete this.plugins[pluginName];
      }
    }
    /**
     * Select some of the lifycycle hooks.
     */
    pickLifyCycle(keys) {
      return pick(this.lifecycle, keys);
    }
    /**
     * Determine whether a plugin is registered.
     */
    isUsed(pluginName) {
      assert(pluginName, 'Must provide a "name".');
      return hasOwn(this.plugins, pluginName);
    }
    /**
     * Create a new plugin system.
     */
    create(callback) {
      return new PluginSystem(callback(HOOKS));
    }
    /**
     * Clone a brand new pluginSystem instance.
     */
    clone(usePlugin) {
      const newLifecycle = Object.create(null);
      for (const key in this.lifecycle) {
        newLifecycle[key] = this.lifecycle[key].clone();
      }
      const cloned = new this.constructor(newLifecycle);
      if (usePlugin) {
        for (const key in this.plugins) {
          cloned.use(this.plugins[key]);
        }
      }
      return cloned;
    }
  }

  exports.AsyncHook = AsyncHook;
  exports.AsyncParallelHook = AsyncParallelHook;
  exports.AsyncWaterfallHook = AsyncWaterfallHook;
  exports.PluginSystem = PluginSystem;
  exports.SyncHook = SyncHook;
  exports.SyncWaterfallHook = SyncWaterfallHook;
});
