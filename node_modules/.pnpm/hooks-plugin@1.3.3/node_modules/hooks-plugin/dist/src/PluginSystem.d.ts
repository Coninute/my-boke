import { SyncHook } from './SyncHook';
import { AsyncHook } from './AsyncHook';
import { AsyncParallelHook } from './AsyncParallelHook';
import { SyncWaterfallHook } from './SyncWaterfallHook';
import { AsyncWaterfallHook } from './AsyncWaterfallHook';
import { createPerformance } from './Performance';
import { type DebuggerOptions } from './Debugger';
import type {
  Plugin,
  PluginApis,
  RefinePlugin,
  EachCallback,
  ListenErrorEvent,
} from './Interface';
declare const HOOKS: {
  SyncHook: typeof SyncHook;
  AsyncHook: typeof AsyncHook;
  AsyncParallelHook: typeof AsyncParallelHook;
  SyncWaterfallHook: typeof SyncWaterfallHook;
  AsyncWaterfallHook: typeof AsyncWaterfallHook;
};
export declare class PluginSystem<T extends Record<string, unknown>> {
  private _locked;
  private _debugs;
  private _performances;
  private _lockListenSet;
  lifecycle: T;
  plugins: Record<string, Plugin<T, PluginApis[string]>>;
  constructor(lifecycle?: T);
  /**
   * @internal
   */
  private _onEmitLifeHook;
  /**
   * Observing the changes in `lock`.
   */
  listenLock(fn: (locked: boolean) => void): void;
  /**
   * Lock the plugin system. After locking, you will not be able to register and uninstall plugins.
   */
  lock(): void;
  /**
   * Unlock the plugin system. After unlocking, you can re-register and uninstall plugins.
   */
  unlock(): void;
  /**
   * Registers a (sync) callback to be called before each hook is being called.
   */
  beforeEach<T extends Array<unknown>, C extends unknown>(
    fn: EachCallback<T, C>,
  ): () => void;
  /**
   * Registers a (sync) callback to be called after each hook is being called.
   */
  afterEach<T extends Array<unknown>, C extends unknown>(
    fn: EachCallback<T, C>,
  ): () => void;
  /**
   * Monitor elapsed time between hooks.
   */
  performance(defaultCondition: string): ReturnType<typeof createPerformance>;
  /**
   * Remove all performance monitoring.
   */
  removeAllPerformance(): void;
  /**
   * Add debugger.
   */
  debug(options?: DebuggerOptions): () => void;
  /**
   * Remove all debug instances.
   */
  removeAllDebug(): void;
  /**
   * Get the `apis` of a plugin.
   */
  getPluginApis<N extends keyof PluginApis>(pluginName: N): PluginApis[N];
  /**
   * Listen for errors when the hook is running.
   */
  listenError(fn: (data: ListenErrorEvent) => void): () => void;
  /**
   * Register refine plugin.
   */
  useRefine<P extends RefinePlugin<T>>(plugin: P): P;
  useRefine<F extends (plSys: this) => RefinePlugin<T>>(
    plugin: F,
  ): ReturnType<F>;
  /**
   * Register plugin.
   */
  use<P extends Plugin<T>>(plugin: P, _flag?: symbol): P;
  use<F extends (plSys: this) => Plugin<T>>(
    plugin: F,
    _flag?: symbol,
  ): ReturnType<F>;
  /**
   * Remove plugin.
   */
  remove(pluginName: string): void;
  /**
   * Select some of the lifycycle hooks.
   */
  pickLifyCycle<T extends keyof this['lifecycle']>(
    keys: Array<T>,
  ): Pick<T, T> extends infer T_1
    ? { [K in keyof T_1]: (T_1 & Pick<T, T>)[K] }
    : never;
  /**
   * Determine whether a plugin is registered.
   */
  isUsed(pluginName: string): boolean;
  /**
   * Create a new plugin system.
   */
  create<T extends (hooks: typeof HOOKS) => Record<string, unknown>>(
    callback: T,
  ): PluginSystem<ReturnType<T>>;
  /**
   * Clone a brand new pluginSystem instance.
   */
  clone(usePlugin?: boolean): this;
}
export {};
