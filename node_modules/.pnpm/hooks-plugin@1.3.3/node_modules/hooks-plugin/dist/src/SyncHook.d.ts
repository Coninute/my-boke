import type {
  TaskId,
  ArgsType,
  Callback,
  HookType,
  ExecErrorEvent,
} from './Interface';
export declare class SyncHook<T extends Array<unknown>, C = null, K = void> {
  private _locked;
  context: C;
  type: HookType;
  listeners: Set<Callback<T, C, K>>;
  tags: WeakMap<Callback<T, C, K>, string>;
  errors: Set<(e: ExecErrorEvent) => void>;
  before?: SyncHook<[TaskId, HookType, C, ArgsType<T>]>;
  after?: SyncHook<[TaskId, HookType, C, ArgsType<T>, Record<string, number>]>;
  constructor(context?: C, _type?: HookType, _internal?: Symbol);
  /**
   * @internal
   */
  protected _emitError(
    error: unknown,
    hook: (...args: Array<any>) => any,
    tag?: string,
  ): void;
  /**
   * Determine whether there is an executable callback function.
   */
  isEmpty(): boolean;
  /**
   * By locking the current hook, you will no longer be able to add or remove callback functions from it.
   */
  lock(): this;
  /**
   * Unlock the current hook.
   */
  unlock(): this;
  /**
   * Register a hook.
   */
  on(fn: Callback<T, C, K>): void;
  on(tag: string, fn: Callback<T, C, K>): void;
  /**
   * Register a single-use hook.
   */
  once(fn: Callback<T, C, K>): void;
  once(tag: string, fn: Callback<T, C, K>): void;
  /**
   * trigger hooks.
   */
  emit(...data: ArgsType<T>): void;
  /**
   * Remove all hooks.
   */
  remove(fn: Callback<T, C, K>, _flag?: Symbol): this;
  /**
   * Remove a specific hook.
   */
  removeAll(): this;
  /**
   * Listen for errors when the hook is running.
   */
  listenError(fn: (e: ExecErrorEvent) => void): void;
  /**
   *  Clone a clean instance.
   */
  clone(): this;
}
