'use strict';

var smallQueue = require('small-queue');

// https://github.com/validatorjs/validator.js/blob/master/src/lib/isMobilePhone.js
const phones = {
  'zh-CN': /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
  'am-AM': /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
  'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
  'ar-LB': /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
  'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
  'ar-KW': /^(\+?965)([569]\d{7}|41\d{6})$/,
  'ar-LY': /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
  'ar-MA': /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
  'ar-OM': /^((\+|00)968)?(9[1-9])\d{6}$/,
  'ar-PS': /^(\+?970|0)5[6|9](\d{7})$/,
  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
  'ar-SD': /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
  'az-AZ': /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
  'bs-BA': /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
  'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
  'ca-AD': /^(\+376)?[346]\d{5}$/,
  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'de-DE': /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
  'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
  'de-CH': /^(\+41|0)([1-9])\d{1,9}$/,
  'de-LU': /^(\+352)?((6\d1)\d{6})$/,
  'dv-MV': /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
  'el-GR': /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
  'el-CY': /^(\+?357?)?(9(9|6)\d{6})$/,
  'en-AI':
    /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
  'en-AU': /^(\+?61|0)4\d{8}$/,
  'en-AG': /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
  'en-BM': /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
  'en-BS': /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
  'en-GB': /^(\+?44|0)7[1-9]\d{8}$/,
  'en-GG': /^(\+?44|0)1481\d{6}$/,
  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
  'en-GY': /^(\+592|0)6\d{6}$/,
  'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
  'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
  'en-JM': /^(\+?876)?\d{7}$/,
  'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
  'fr-CF': /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
  'en-SS': /^(\+?211|0)(9[1257])\d{7}$/,
  'en-KI': /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
  'en-KN': /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
  'en-LS': /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
  'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
  'en-MU': /^(\+?230|0)?\d{8}$/,
  'en-MW':
    /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
  'en-NA': /^(\+?264|0)(6|8)\d{7}$/,
  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
  'en-PG': /^(\+?675|0)?(7\d|8[18])\d{6}$/,
  'en-PK': /^((00|\+)?92|0)3[0-6]\d{8}$/,
  'en-PH': /^(09|\+639)\d{9}$/,
  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
  'en-SG': /^(\+65)?[3689]\d{7}$/,
  'en-SL': /^(\+?232|0)\d{8}$/,
  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
  'en-US':
    /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  'en-ZA': /^(\+?27|0)\d{9}$/,
  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
  'en-ZW': /^(\+263)[0-9]{9}$/,
  'en-BW': /^(\+?267)?(7[1-8]{1})\d{6}$/,
  'es-AR': /^\+?549(11|[2368]\d)\d{8}$/,
  'es-BO': /^(\+?591)?(6|7)\d{7}$/,
  'es-CO': /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
  'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
  'es-CR': /^(\+506)?[2-8]\d{7}$/,
  'es-CU': /^(\+53|0053)?5\d{7}$/,
  'es-DO': /^(\+?1)?8[024]9\d{7}$/,
  'es-HN': /^(\+?504)?[9|8|3|2]\d{7}$/,
  'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
  'es-ES': /^(\+?34)?[6|7]\d{8}$/,
  'es-GT': /^(\+?502)?[2|6|7]\d{7}$/,
  'es-PE': /^(\+?51)?9\d{8}$/,
  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
  'es-NI': /^(\+?505)\d{7,8}$/,
  'es-PA': /^(\+?507)\d{7,8}$/,
  'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
  'es-SV': /^(\+?503)?[67]\d{7}$/,
  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
  'es-VE': /^(\+?58)?(2|4)\d{9}$/,
  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  'fi-FI': /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
  'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'fr-BF': /^(\+226|0)[67]\d{7}$/,
  'fr-BJ': /^(\+229)\d{8}$/,
  'fr-CD': /^(\+?243|0)?(8|9)\d{8}$/,
  'fr-CM': /^(\+?237)6[0-9]{8}$/,
  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
  'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
  'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
  'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
  'fr-PF': /^(\+?689)?8[789]\d{6}$/,
  'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
  'fr-WF': /^(\+681)?\d{6}$/,
  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  'hu-HU': /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
  'id-ID':
    /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  'ir-IR': /^(\+98|0)?9\d{9}$/,
  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  'it-SM': /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
  'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
  'ka-GE': /^(\+?995)?(79\d{7}|5\d{8})$/,
  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  'ky-KG': /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
  'lt-LT': /^(\+370|8)\d{8}$/,
  'lv-LV': /^(\+?371)2\d{7}$/,
  'mg-MG': /^((\+?261|0)(2|3)\d)?\d{7}$/,
  'mn-MN': /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
  'my-MM': /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
  'ms-MY': /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
  'mz-MZ': /^(\+?258)?8[234567]\d{7}$/,
  'nb-NO': /^(\+?47)?[49]\d{7}$/,
  'ne-NP': /^(\+?977)?9[78]\d{8}$/,
  'nl-BE': /^(\+?32|0)4\d{8}$/,
  'nl-NL': /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
  'nl-AW': /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
  'nn-NO': /^(\+?47)?[49]\d{7}$/,
  'pl-PL': /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
  'pt-BR':
    /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
  'pt-AO': /^(\+244)\d{9}$/,
  'ro-MD': /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
  'ro-RO': /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
  'ru-RU': /^(\+?7|8)?9\d{9}$/,
  'si-LK': /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
  'sl-SI':
    /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'so-SO': /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
  'sq-AL': /^(\+355|0)6[789]\d{6}$/,
  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  'tg-TJ': /^(\+?992)?[5][5]\d{7}$/,
  'th-TH': /^(\+66|66|0)\d{9}$/,
  'tr-TR': /^(\+?90|0)?5\d{9}$/,
  'tk-TM': /^(\+993|993|8)\d{8}$/,
  'uk-UA': /^(\+?38)?0(50|6[36-8]|7[357]|9[1-9])\d{7}$/,
  'uz-UZ': /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
  'vi-VN':
    /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
  'dz-BT': /^(\+?975|0)?(17|16|77|02)\d{6}$/,
  'ar-YE': /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
  'ar-EH': /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
  'fa-AF': /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/,
  // aliases
  get 'en-CA'() {
    return phones['en-US'];
  },
  get 'fr-CA'() {
    return phones['en-CA'];
  },
  get 'fr-BE'() {
    return phones['nl-BE'];
  },
  get 'zh-HK'() {
    return phones['en-HK'];
  },
  get 'zh-MO'() {
    return phones['en-MO'];
  },
  get 'ga-IE'() {
    return phones['en-IE'];
  },
  get 'fr-CH'() {
    return phones['de-CH'];
  },
  get 'it-CH'() {
    return phones['fr-CH'];
  },
};

const objectToString = Object.prototype.toString;
const supportWasm = typeof WebAssembly === 'object';
const toRawType = (v) => {
  return objectToString.call(v).slice(8, -1).toLowerCase();
};
const isArray = /*#__PURE__*/ (() => Array.isArray)();
const isBrowser = typeof window !== 'undefined';
const isNil = (v) => {
  return v === undefined || v === null;
};
const isObject = (v) => {
  return v !== null && typeof v === 'object';
};
const isNumber = (v) => {
  return typeof v === 'number';
};
const isString = (v) => {
  return typeof v === 'string';
};
const isPort = (n) => {
  return Number.isInteger(n) && n >= 0 && n <= 65535;
};
const isDate = (v) => {
  return objectToString.call(v) === '[object Date]';
};
const isRegExp = (v) => {
  return objectToString.call(v) === '[object RegExp]';
};
const isPromise = (v) => {
  return v instanceof Promise;
};
const isPromiseLike = (v) => {
  return isObject(v) && typeof v.then === 'function';
};
const isPlainObject = (v) => {
  return objectToString.call(v) === '[object Object]';
};
const isFunction = (v) => {
  return typeof v === 'function';
};
const unc = /^[a-zA-Z]:\\/;
const uri = /^[a-zA-Z][a-zA-Z\d+\-.]*:/;
const isAbsolute = (p) => {
  return !unc.test(p) && uri.test(p);
};
const isWindow = (val) => {
  return (
    typeof window !== 'undefined' &&
    objectToString.call(val) === '[object Window]'
  );
};
const typeArrTag =
  /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
const isTypedArray = (val) => {
  return typeArrTag.test(objectToString.call(val));
};
const isSet =
  typeof Set !== 'function' || !(/*#__PURE__*/ (() => Set.prototype.has)())
    ? () => false
    : (v) => isObject(v) && v instanceof Set;
const isWeakSet =
  typeof WeakSet !== 'function' ||
  !(/*#__PURE__*/ (() => WeakSet.prototype.has)())
    ? () => false
    : (v) => isObject(v) && v instanceof WeakSet;
const isMap =
  typeof Map !== 'function' || !(/*#__PURE__*/ (() => Map.prototype.has)())
    ? () => false
    : (v) => isObject(v) && v instanceof Map;
const isWeakMap =
  typeof WeakMap !== 'function' ||
  !(/*#__PURE__*/ (() => WeakMap.prototype.has)())
    ? () => false
    : (v) => isObject(v) && v instanceof WeakMap;
const isBuffer = (v) => {
  if (!isObject(v)) return false;
  return Boolean(
    v.constructor && v.constructor.isBuffer && v.constructor.isBuffer(v),
  );
};
const isInBounds = ([a, b], v) => {
  if (v === a || v === b) return true;
  const min = Math.min(a, b);
  const max = min === a ? b : a;
  return min < v && v < max;
};
const isEmptyObject = (val) => {
  for (const _ in val) return false;
  return true;
};
const isPrimitiveValue = (v) => {
  return (
    typeof v === 'number' ||
    typeof v === 'bigint' ||
    typeof v === 'string' ||
    typeof v === 'symbol' ||
    typeof v === 'boolean' ||
    v === undefined ||
    v === null
  );
};
const isWhitespace = (char) => {
  return (
    char === ' ' ||
    char === '\t' ||
    char === '\n' ||
    char === '\r' ||
    char === '\f' ||
    char === '\v'
  );
};
const isByteLength = (val, options = {}) => {
  const min = options.min || 0;
  const max = options.max;
  const len = encodeURI(val).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
};
const notBase64 = /[^A-Z0-9+\/=]/i;
const urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
const isBase64 = (val, urlSafe = false) => {
  const len = val.length;
  if (urlSafe) return urlSafeBase64.test(val);
  if (len % 4 !== 0 || notBase64.test(val)) return false;
  const firstPaddingChar = val.indexOf('=');
  return (
    firstPaddingChar === -1 ||
    firstPaddingChar === len - 1 ||
    (firstPaddingChar === len - 2 && val[len - 1] === '=')
  );
};
const IPv4SegmentFormat =
  '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
const IPv4AddressFormat = /*#__PURE__*/ (() =>
  `(${IPv4SegmentFormat}[.]){3}${IPv4SegmentFormat}`)();
const IPv4AddressRegExp = /*#__PURE__*/ (() =>
  new RegExp(`^${IPv4AddressFormat}$`))();
const IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
const IPv6AddressRegExp = /*#__PURE__*/ (() =>
  new RegExp(
    '^(' +
      `(?:${IPv6SegmentFormat}:){7}(?:${IPv6SegmentFormat}|:)|` +
      `(?:${IPv6SegmentFormat}:){6}(?:${IPv4AddressFormat}|:${IPv6SegmentFormat}|:)|` +
      `(?:${IPv6SegmentFormat}:){5}(?::${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,2}|:)|` +
      `(?:${IPv6SegmentFormat}:){4}(?:(:${IPv6SegmentFormat}){0,1}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,3}|:)|` +
      `(?:${IPv6SegmentFormat}:){3}(?:(:${IPv6SegmentFormat}){0,2}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,4}|:)|` +
      `(?:${IPv6SegmentFormat}:){2}(?:(:${IPv6SegmentFormat}){0,3}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,5}|:)|` +
      `(?:${IPv6SegmentFormat}:){1}(?:(:${IPv6SegmentFormat}){0,4}:${IPv4AddressFormat}|(:${IPv6SegmentFormat}){1,6}|:)|` +
      `(?::((?::${IPv6SegmentFormat}){0,5}:${IPv4AddressFormat}|(?::${IPv6SegmentFormat}){1,7}|:))` +
      ')(%[0-9a-zA-Z-.:]{1,})?$',
  ))();
// https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js
const isIP = (val, version) => {
  if (!version) return isIP(val, '4') || isIP(val, '6');
  if (version === '4') return IPv4AddressRegExp.test(val);
  if (version === '6') return IPv6AddressRegExp.test(val);
  return false;
};
const isDomain = (val) => {
  const parts = val.split('.');
  if (parts.length < 2) return false;
  const tld = parts[parts.length - 1];
  const reg =
    /^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i;
  if (!reg.test(tld)) return false;
  if (/\s/.test(tld)) return false;
  if (/^\d+$/.test(tld)) return false;
  return parts.every((part) => {
    if (part.length > 63) return false;
    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) return false;
    if (/[\uff01-\uff5e]/.test(part)) return false;
    if (/^-|-$/.test(part)) return false;
    if (/_/.test(part)) return false;
    return true;
  });
};
const isPhone = (val, locale, strictMode) => {
  if (strictMode && !val.startsWith('+')) {
    return false;
  }
  if (typeof locale === 'string' && locale in phones) {
    return phones[locale].test(val);
  }
  if (isArray(locale)) {
    return locale.some((key) => {
      if (phones.hasOwnProperty(key)) {
        if (phones[key].test(val)) return true;
      }
      return false;
    });
  }
  if (!locale) {
    for (const key in phones) {
      if (phones.hasOwnProperty(key)) {
        const phone = phones[key];
        if (phone.test(val)) return true;
      }
    }
    return false;
  }
  throw new Error(`Invalid locale '${locale}'`);
};
const isCNPhone = (val, strictMode) => isPhone(val, 'zh-CN', strictMode);
const emailUserUtf8Part =
  /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
const quotedEmailUserUtf8 =
  /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
/**
 * Not verify `display_name`
 * */
const isEmail = (val, options) => {
  // If greater than default max email length
  if (val.length > 254) return false;
  const parts = val.split('@');
  const domain = parts.pop();
  if (!domain) return false;
  let user = parts.join('@');
  if (!isByteLength(user, { max: 64 }) || !isByteLength(domain, { max: 254 })) {
    return false;
  }
  if (!isDomain(domain)) {
    if (options && options.disableIPDomain) {
      return false;
    }
    // user@[192.168.1.1]
    // user@[2001:0db8:85a3:0000:0000:8a2e:0370:7334]
    if (!isIP(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }
      const noBracketdomain = domain.slice(1, -1);
      if (noBracketdomain.length === 0 || !isIP(noBracketdomain)) {
        return false;
      }
    }
  }
  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return quotedEmailUserUtf8.test(user);
  }
  const userParts = user.split('.');
  for (let i = 0; i < userParts.length; i++) {
    if (!emailUserUtf8Part.test(userParts[i])) {
      return false;
    }
  }
  return true;
};

const freeSelf = /*#__PURE__*/ (() =>
  typeof self === 'object' &&
  self !== null &&
  self.Object === Object &&
  self)();
const freeGlobal = /*#__PURE__*/ (() =>
  typeof global === 'object' &&
  global !== null &&
  global.Object === Object &&
  global)();
const freeGlobalThis = /*#__PURE__*/ (() =>
  typeof globalThis === 'object' &&
  globalThis !== null &&
  globalThis.Object === Object &&
  globalThis)();
const root =
  freeGlobalThis ||
  freeGlobal ||
  freeSelf ||
  /*#__PURE__*/
  (function () {
    return this;
  })();

let byteToHex;
const unsafeStringify = (arr) => {
  if (!byteToHex) {
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }
  }
  return (
    byteToHex[arr[0]] +
    byteToHex[arr[1]] +
    byteToHex[arr[2]] +
    byteToHex[arr[3]] +
    '-' +
    byteToHex[arr[4]] +
    byteToHex[arr[5]] +
    '-' +
    byteToHex[arr[6]] +
    byteToHex[arr[7]] +
    '-' +
    byteToHex[arr[8]] +
    byteToHex[arr[9]] +
    '-' +
    byteToHex[arr[10]] +
    byteToHex[arr[11]] +
    byteToHex[arr[12]] +
    byteToHex[arr[13]] +
    byteToHex[arr[14]] +
    byteToHex[arr[15]]
  ).toLowerCase();
};
let poolPtr;
let rnds8Pool;
const rng = () => {
  if (!rnds8Pool) {
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
  if (poolPtr > 256 - 16) {
    for (let i = 0; i < 256; i++) {
      rnds8Pool[i] = Math.floor(Math.random() * 256);
    }
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, (poolPtr += 16));
};
// https://github.com/uuidjs/uuid/blob/main/src/v4.js
const uuid = () => {
  const rnds = rng();
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;
  return unsafeStringify(rnds);
};

const _new = (val, ...args) => {
  return new val.constructor(...args);
};
const _isRes =
  typeof Response === 'undefined' ? (v) => false : (v) => v instanceof Response;
function clone$1(val, options) {
  let exclude;
  let ignoreError;
  let includeNonEnum;
  if (typeof options === 'boolean') {
    includeNonEnum = options;
  } else if (isSet(options) || isWeakSet(options)) {
    exclude = options;
  } else if (isObject(options)) {
    ({ exclude, ignoreError, includeNonEnum } = options);
  }
  const allChildren = new WeakMap();
  const _cv = (child, key, descriptor) => {
    if (!descriptor) return;
    if ('value' in descriptor) {
      Object.defineProperty(child, key, {
        ...descriptor,
        value: _cl(descriptor.value),
      });
    } else if (descriptor.get || descriptor.set) {
      try {
        Object.defineProperty(child, key, descriptor);
      } catch (e) {
        // when in strict mode, TypeError will be thrown if parent[k] property only has a getter
        if (!ignoreError) {
          console.error(e);
        }
      }
    }
  };
  const _cl = (parent) => {
    if (parent === null || typeof parent !== 'object') {
      return parent;
    }
    if (exclude && exclude.has(parent)) {
      return parent;
    }
    if (allChildren.has(parent)) {
      return allChildren.get(parent);
    }
    let child;
    // Create a child
    if (isMap(parent)) {
      child = _new(parent);
    } else if (isSet(parent)) {
      child = _new(parent);
    } else if (isArray(parent)) {
      child = _new(parent);
    } else if (isTypedArray(parent)) {
      child = parent.slice();
    } else if (isRegExp(parent)) {
      child = _new(parent, parent.source, parent.flags);
      if (parent.lastIndex) {
        child.lastIndex = parent.lastIndex;
      }
    } else if (isDate(parent)) {
      child = _new(parent, parent.getTime());
    } else if (parent instanceof Error) {
      child = Object.create(parent);
    } else if (_isRes(parent)) {
      child = parent.clone();
    } else if (isBuffer(parent)) {
      child = Buffer.from(parent);
    } else if (parent instanceof Promise) {
      child = _new(parent, (resolve, reject) => {
        parent.then(
          (v) => {
            resolve(_cl(v));
          },
          (e) => {
            reject(_cl(e));
          },
        );
      });
    } else {
      const proto = Object.getPrototypeOf(parent);
      child = Object.create(proto);
    }
    // Save the mapping relationship
    allChildren.set(parent, child);
    // Copy items
    if (isMap(parent)) {
      parent.forEach((val, key) => {
        child.set(_cl(key), _cl(val));
      });
    } else if (isSet(parent)) {
      parent.forEach((val) => {
        child.add(_cl(val));
      });
    }
    // Copy object
    for (const key in parent) {
      _cv(child, key, Object.getOwnPropertyDescriptor(parent, key));
    }
    // Copy symbol keys
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(parent);
      for (let i = 0; i < symbols.length; i++) {
        const symbol = symbols[i];
        const descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (!descriptor || (!descriptor.enumerable && !includeNonEnum)) {
          continue;
        }
        _cv(child, symbol, descriptor);
      }
    }
    // Copy non-enumerable properties
    if (includeNonEnum) {
      const ns = Object.getOwnPropertyNames(parent);
      for (let i = 0; i < ns.length; i++) {
        const n = ns[i];
        const descriptor = Object.getOwnPropertyDescriptor(parent, n);
        if (!descriptor || descriptor.enumerable) {
          continue;
        }
        _cv(child, n, descriptor);
      }
    }
    return child;
  };
  return _cl(val);
}

const prevent = (val, { excludeSet }) => {
  return isObject(val) && excludeSet && excludeSet.has(val);
};
const isMergeableObject = (val) => {
  return (
    isObject(val) &&
    !isDate(val) &&
    !isRegExp(val) &&
    val.$$typeof !== Symbol.for('react.element')
  );
};
const getEnumerableSymbols = (target) => {
  return Object.getOwnPropertySymbols(target).filter((symbol) =>
    Object.propertyIsEnumerable.call(target, symbol),
  );
};
const getKeys = (target) => {
  return Object.keys(target).concat(getEnumerableSymbols(target));
};
const propertyIsOnObject = (object, key) => {
  try {
    return key in object;
  } catch (e) {
    return false;
  }
};
const propertyIsUnsafe = (target, key) => {
  return (
    propertyIsOnObject(target, key) &&
    !(
      Object.hasOwnProperty.call(target, key) &&
      Object.propertyIsEnumerable.call(target, key)
    )
  );
};
const clone = (val, option) => {
  if (!isMergeableObject(val)) return val;
  return merge(Array.isArray(val) ? [] : {}, val, option);
};
const mergeArray = (target, source, option) => {
  let arr = option.arrayStrategy === 'replace' ? source : target.concat(source);
  if (option.ignoreUndef) {
    arr = arr.filter((val) => val !== undefined);
  }
  return arr.map((val) => clone(val, option));
};
const mergeObject = (target, source, option) => {
  const res = {};
  const isUndef = (val) => option.ignoreUndef && val === undefined;
  if (isMergeableObject(target)) {
    const keys = getKeys(target);
    for (const key of keys) {
      const val = target[key];
      if (isUndef(val)) continue;
      res[key] = prevent(val, option) ? val : clone(val, option);
    }
  }
  const keys = getKeys(source);
  for (const key of keys) {
    if (propertyIsUnsafe(target, key)) continue;
    if (propertyIsOnObject(target, key) && isMergeableObject(source[key])) {
      if (prevent(source[key], option)) {
        res[key] = source[key];
      } else if (prevent(target[key], option)) {
        if (!isUndef(target[key])) {
          res[key] = target[key];
        }
      } else {
        res[key] = merge(target[key], source[key], option);
      }
    } else if (!isUndef(source[key])) {
      res[key] = prevent(source[key], option)
        ? source[key]
        : clone(source[key], option);
    }
  }
  return res;
};
// This should not be a structure with circular references
const merge = (target, source, option = {}) => {
  const sourceIsArray = Array.isArray(source);
  const targetIsArray = Array.isArray(target);
  if (sourceIsArray !== targetIsArray) {
    return clone(source, option);
  } else if (sourceIsArray) {
    return mergeArray(target, source, option);
  } else {
    return mergeObject(target, source, option);
  }
};

/**
 * Give the current task one frame of time (default is 17ms).
 * If it exceeds one frame, the remaining tasks will be put into the next frame.
 */
const loopSlice = (l, fn, taskTime = 17) => {
  return new Promise((resolve) => {
    if (l === 0) {
      resolve();
      return;
    }
    let i = -1;
    let start = Date.now();
    const run = () => {
      while (++i < l) {
        if (fn(i) === false) {
          resolve();
          break;
        }
        if (i === l - 1) {
          resolve();
        } else {
          const t = Date.now();
          if (t - start > taskTime) {
            start = t;
            raf(run);
            break;
          }
        }
      }
    };
    run();
  });
};

// The extends type includes `undefined` to match optional characters.
const throttle = (delay, fn, _isDebounce) => {
  let lastExec = 0;
  let cancelled = false;
  let timer = null;
  const clear = () => (timer = null);
  function wrapper(...args) {
    if (cancelled) return;
    const cur = Date.now();
    const elapsed = cur - lastExec;
    const exec = (cur) => {
      lastExec = cur || Date.now();
      fn.apply(this, args);
    };
    // Default begin call
    if (_isDebounce && !timer) {
      exec(cur);
    }
    if (timer) {
      clearTimeout(timer);
    }
    if (!_isDebounce && elapsed > delay) {
      exec(cur);
    } else {
      timer = setTimeout(
        _isDebounce ? clear : exec,
        _isDebounce ? delay : delay - elapsed,
      );
    }
  }
  wrapper.cancel = () => {
    if (timer) {
      clearTimeout(timer);
    }
    clear();
    cancelled = true;
  };
  return wrapper;
};
const debounce = (delay, fn) => throttle(delay, fn, true);

function createCacheObject(max, { onGet, onSet, onRemove, permanents } = {}) {
  if (max < 0) max = 0;
  let allSize = 0;
  const data = Object.create(null);
  const isPermanent = permanents ? makeMap(permanents) : () => false;
  const has = (key) => !isNil(data[key]);
  const remove = (key) => {
    if (data[key]) {
      const unit = data[key];
      allSize -= unit.size;
      if (allSize < 0) {
        allSize = 0;
      }
      delete data[key];
      if (typeof onRemove === 'function') {
        onRemove(key, { ...unit });
      }
    }
  };
  const removeAll = () => {
    for (const key in data) {
      remove(key);
    }
  };
  // When getting a not exist key, an error will be reported.
  // Should use `has` to check first.
  const get = (key) => {
    assert(data[key], `"${key}" does not exist`);
    data[key].count++;
    if (typeof onGet === 'function') {
      const ref = { ...data[key] };
      onGet(key, ref);
      return ref.value;
    } else {
      return data[key].value;
    }
  };
  const set = (key, value, size, force) => {
    let isInit = false;
    let unit = data[key];
    if (!unit) {
      isInit = true;
      unit = data[key] = Object.create(null);
      unit.size = 0;
      unit.count = 0;
    }
    if (typeof onSet === 'function') {
      const ref = { size, value, count: unit.count };
      onSet(key, ref);
      size = ref.size;
      value = ref.value;
    }
    const diff = size - unit.size;
    const canSet = (s) => s + diff <= max;
    if (size <= max) {
      if (!canSet(allSize)) {
        let tempSize = allSize;
        const keys = Object.keys(data);
        const queue = [];
        const tryRemove = once(() => {
          let l = queue.length;
          let extra = max - tempSize - diff;
          while (~--l) {
            if (extra > 0 && extra >= queue[l][1]) {
              extra -= queue[l][1];
            } else {
              remove(queue[l][0]);
            }
          }
        });
        keys.sort((a, b) => {
          const d = data[a].count - data[b].count;
          return d === 0 ? data[a].size - data[b].size : d;
        });
        for (let i = 0; i < keys.length; i++) {
          const u = data[keys[i]];
          if (canSet(tempSize)) {
            tryRemove();
            break;
          }
          if (keys[i] !== key && !isPermanent(keys[i])) {
            if (
              force ||
              u.count < unit.count ||
              (u.count === unit.count && u.size < size)
            ) {
              tempSize -= u.size;
              if (tempSize < 0) tempSize = 0;
              queue.push([keys[i], u.size]);
            }
          }
        }
        if (canSet(tempSize)) {
          tryRemove();
        }
      }
      if (canSet(allSize)) {
        allSize += size - unit.size;
        unit.size = size;
        unit.value = value;
        return true;
      }
    }
    if (isInit) {
      delete data[key];
    }
    return false;
  };
  return {
    has,
    get,
    set,
    max,
    remove,
    removeAll,
    get size() {
      return allSize;
    },
    get keys() {
      return Object.keys(data);
    },
    get bucket() {
      return data;
    },
  };
}

const inlineString = (code) => {
  const obj = {};
  obj[code] = true;
  return Object.keys(obj)[0];
};
const esmEnvCode = (env, bridge) => {
  if (env) {
    let str = 'var ';
    for (const key in env) {
      str += `${key}=globalThis.${bridge}.${key},`;
    }
    return str.slice(0, -1) + ';';
  }
  return '';
};
function exec(code, type, options) {
  const { env, sourceUrl, useStrict } = options || {};
  const sourceCode = sourceUrl ? `\n//# sourceURL=${sourceUrl}\n` : '\n';
  if (type && type.startsWith('esm')) {
    const bridge = `__aidlyExec${random(10000)}__`;
    const esmCode = `${esmEnvCode(env, bridge)}${code}${sourceCode}`;
    const id =
      type === 'esm:data'
        ? `data:text/javascript;charset=utf-8,${encodeURIComponent(esmCode)}`
        : URL.createObjectURL(new Blob([esmCode], { type: 'text/javascript' }));
    try {
      if (env) globalThis[bridge] = env;
      return (0, eval)(inlineString(`import("${id}")`)).finally(() => {
        delete globalThis[bridge];
      });
    } catch (e) {
      delete globalThis[bridge];
      throw e;
    }
  } else {
    const keys = Object.keys(env || {});
    const values = keys.map((key) => env[key]);
    const paramsCode = keys.join(',');
    const strictCode = useStrict ? '"use strict";' : '';
    const cjsCode = type === 'cjs' ? 'module,exports,' : '';
    const fn = (0, eval)(
      inlineString(
        `(()=>function _$c_(${cjsCode}${paramsCode}){${strictCode}${code}${sourceCode}})();`,
      ),
    );
    if (type === 'cjs') {
      const ms = { exports: Object.create(null) };
      fn(ms, ms.exports, ...values);
      return ms.exports;
    }
    return fn(...values);
  }
}

class Calculator {
  expr;
  i = 0;
  priority = {
    '+': 1,
    '-': 1,
    '*': 2,
    '/': 2,
    '%': 2,
  };
  constructor(expr) {
    this.expr = expr;
  }
  calculateOperation(numbers, operator) {
    const b = numbers.pop();
    const a = numbers.pop();
    if (a !== undefined && b !== undefined) {
      switch (operator) {
        case '+':
          numbers.push(a + b);
          break;
        case '-':
          numbers.push(a - b);
          break;
        case '*':
          numbers.push(a * b);
          break;
        case '/':
          numbers.push(a / b);
          break;
        case '%':
          numbers.push(a % b);
          break;
        default:
          throw new Error(`Invalid operator: "${operator}"`);
      }
    }
  }
  evaluate(tokens) {
    if (tokens.length === 0) return NaN;
    const numbers = [];
    const operators = [];
    for (const token of tokens) {
      if (typeof token === 'string') {
        const cur = this.priority[token];
        while (operators.length > 0 && this.priority[last(operators)] >= cur) {
          this.calculateOperation(numbers, operators.pop());
        }
        operators.push(token);
      } else {
        numbers.push(token);
      }
    }
    while (operators.length > 0) {
      this.calculateOperation(numbers, operators.pop());
    }
    const n = numbers.pop();
    return typeof n === 'number' ? n : NaN;
  }
  tokenizer() {
    const tokens = [];
    if (!this.expr) return tokens;
    let buf = '';
    const add = () => {
      if (buf) {
        tokens.push(Number(buf));
        buf = '';
      }
    };
    for (; this.i < this.expr.length; this.i++) {
      const char = this.expr[this.i];
      if (isWhitespace(char));
      else if (char === '+' || char === '-') {
        const prevToken = last(tokens);
        if (!buf && (!prevToken || prevToken in this.priority)) {
          buf += char;
        } else {
          add();
          tokens.push(char);
        }
      } else if (char === '*' || char === '/' || char === '%') {
        add();
        tokens.push(char);
      } else if (char === '(') {
        this.i++;
        tokens.push(this.evaluate(this.tokenizer()));
      } else if (char === ')') {
        this.i++;
        add();
        return tokens;
      } else {
        buf += char;
      }
    }
    add();
    return tokens;
  }
}
const isLegalExpression = (expr) => {
  const keywords = '\',",`,:,;,[,{,=,var,let,const,return'.split(',');
  for (const word of keywords) {
    if (expr.includes(word)) {
      return false;
    }
  }
  return !/[^\+\-\*\/\%\s]+\(/.test(expr);
};
const mathExprEvaluate = (expr, options) => {
  const { units, verify, actuator, exec = true } = options || {};
  if (verify && !isLegalExpression(expr)) {
    throw new Error(`Invalid expression: "${expr}"`);
  }
  expr = expr.replace(
    /(-?\d+(\.\d+)?|NaN|Infinity)([^\d\s\+\-\*\/\.\(\)]+)?/g,
    ($1, n, $3, u, $4) => {
      if (!u) return n;
      const parser = units && (units[u] || units['default']);
      if (!parser) throw new Error(`Invalid unit: "${u}"`);
      return String(parser(n, u, expr));
    },
  );
  try {
    if (actuator) {
      return actuator(expr, Boolean(exec));
    } else {
      if (!exec) return expr;
      const calculator = new Calculator(expr);
      return calculator.evaluate(calculator.tokenizer());
    }
  } catch (e) {
    throw new Error(`Invalid expression: "${expr}", error: "${e}"`);
  }
};

// Object references are a built-in behavior of es, so `@@` is used here.
const defaultFlag = '@@ref*';
const createJSONParse = ({ flag, parse } = {}) => {
  if (typeof flag !== 'string') flag = defaultFlag;
  if (typeof parse !== 'function') parse = JSON.parse;
  return (text, reviver) => {
    const map = new Map();
    const refs = Object.create(null);
    const replace = [];
    const refKey = (v) => v.slice(flag.length);
    const isRefStr = (v) => {
      return typeof v === 'string' && v.startsWith(flag);
    };
    function _reviver(key, value) {
      let isRef = false;
      if (flag) {
        if (!map.has(this)) {
          map.set(this, {});
        }
        const parent = map.get(this);
        parent[key] = {
          set: [],
          add(p) {
            if (!p) return;
            this.set.unshift(p);
            const children = map.get(value);
            for (const prop in children) {
              children[prop].add(p);
            }
          },
        };
        parent[key].add(key);
        if (isRefStr(value)) {
          isRef = true;
          let ref = refKey(value);
          replace.unshift(() => {
            let refValue = refs[ref];
            while (isRefStr(refValue)) {
              refValue = refs[refKey(refValue)];
            }
            this[key] = refValue;
          });
        }
      }
      return !isRef && typeof reviver === 'function'
        ? reviver.call(this, key, value)
        : value;
    }
    const res = parse(text, _reviver);
    map.forEach((value, key) => {
      for (const prop in value) {
        refs[value[prop].set.join('.')] = key[prop];
      }
    });
    for (const fn of replace) {
      fn();
    }
    return res;
  };
};
const createJSONStringify = ({ flag, stringify } = {}) => {
  if (typeof flag !== 'string') flag = defaultFlag;
  if (typeof stringify !== 'function') stringify = JSON.stringify;
  return (value, replacer, space) => {
    const map = new WeakMap();
    function _replacer(key, value) {
      if (typeof replacer === 'function') {
        value = replacer.call(this, key, value);
      }
      if (flag) {
        if (isObject(value)) {
          let path = key;
          if (map.has(this)) {
            const parent = map.get(this);
            path = parent ? `${parent}.${key}` : key;
          }
          if (map.has(value)) {
            value = `${flag}${map.get(value)}`;
          } else {
            map.set(value, path);
          }
        }
      }
      return value;
    }
    return stringify(value, _replacer, space);
  };
};
const jsonParse = /*#__PURE__*/ createJSONParse();
const jsonStringify = /*#__PURE__*/ createJSONStringify();

const defaultStringifyOptions = {
  encode: true,
  commaRoundTrip: true,
  addQueryPrefix: false,
  arrayFormat: 'indices',
};
const defaultParseOptions = {
  depth: 5,
  arrayLimit: 20,
  comma: true,
  allowSparse: true,
};
const decode = (s) => {
  s = s.replace(/\+/g, ' ');
  try {
    return decodeURIComponent(s);
  } catch (e) {
    return s; // Error case {%:%}
  }
};
let hexTable;
const encode = (str) => {
  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
  // It has been adapted here for stricter adherence to RFC 3986
  if (str.length === 0) return str;
  let s = str;
  const limit = 1024;
  if (typeof str === 'symbol') {
    s = Symbol.prototype.toString.call(str);
  } else if (typeof str !== 'string') {
    s = String(str);
  }
  if (!hexTable) {
    hexTable = [];
    for (let i = 0; i < 256; i++) {
      hexTable.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
  }
  let out = '';
  for (let j = 0; j < s.length; j += limit) {
    const arr = [];
    const segment = s.length >= limit ? s.slice(j, j + limit) : s;
    for (let i = 0; i < segment.length; i++) {
      let c = segment.charCodeAt(i);
      if (
        c === 0x2d || // -
        c === 0x2e || // .
        c === 0x5f || // _
        c === 0x7e || // ~
        (c >= 0x30 && c <= 0x39) || // 0-9
        (c >= 0x41 && c <= 0x5a) || // a-z
        (c >= 0x61 && c <= 0x7a) // A-Z
      ) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 0x80) {
        arr[arr.length] = hexTable[c];
        continue;
      }
      if (c < 0x800) {
        arr[arr.length] =
          hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)];
        continue;
      }
      if (c < 0xd800 || c >= 0xe000) {
        arr[arr.length] =
          hexTable[0xe0 | (c >> 12)] +
          hexTable[0x80 | ((c >> 6) & 0x3f)] +
          hexTable[0x80 | (c & 0x3f)];
        continue;
      }
      i += 1;
      c = 0x10000 + (((c & 0x3ff) << 10) | (segment.charCodeAt(i) & 0x3ff));
      arr[arr.length] =
        hexTable[0xf0 | (c >> 18)] +
        hexTable[0x80 | ((c >> 12) & 0x3f)] +
        hexTable[0x80 | ((c >> 6) & 0x3f)] +
        hexTable[0x80 | (c & 0x3f)];
    }
    out += arr.join('');
  }
  return out;
};
const pushToArray = (arr, valueOrArray) => {
  arr.push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};
const arrayPrefixFns = {
  comma: (p) => p,
  repeat: (p) => p,
  brackets: (p) => `${p}[]`,
  indices: (p, k) => `${p}[${k}]`,
};
const sentinel = {};
const stringify = (object, prefix, commaRoundTrip, sideChannel, options) => {
  let step = 0;
  let obj = object;
  let tmpSc = sideChannel;
  let findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
    const pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== 'undefined') {
      if (pos === step) {
        throw new RangeError('Cyclic object value');
      }
      findFlag = true; // Break while
    }
    if (typeof tmpSc.get(sentinel) === 'undefined') {
      step = 0;
    }
  }
  if (isDate(obj)) {
    obj = obj.toISOString();
  } else if (options.arrayFormat === 'comma' && isArray(obj)) {
    obj = obj.map((val) => (isDate(val) ? val.toISOString() : val));
  }
  if (obj === null) {
    obj = '';
  }
  if ((!isNil(obj) && isPrimitiveValue(obj)) || isBuffer(obj)) {
    return !options.encode
      ? [`${prefix}=${obj}`]
      : [`${encode(prefix)}=${encode(obj)}`];
  }
  const values = [];
  if (typeof obj === 'undefined') return values;
  let objKeys;
  if (options.arrayFormat === 'comma' && isArray(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
  } else {
    objKeys = Object.keys(obj);
  }
  const adjustedPrefix =
    commaRoundTrip && isArray(obj) && obj.length === 1 ? `${prefix}[]` : prefix;
  for (let j = 0; j < objKeys.length; j++) {
    const key = objKeys[j];
    const value =
      typeof key === 'object' && typeof key.value !== 'undefined'
        ? key.value
        : obj[key];
    let keyPrefix;
    if (isArray(obj)) {
      keyPrefix = arrayPrefixFns[options.arrayFormat](adjustedPrefix, key);
    } else {
      keyPrefix = `${adjustedPrefix}[${key}]`;
    }
    sideChannel.set(object, step);
    const valueSideChannel = new Map();
    valueSideChannel.set(sentinel, sideChannel);
    pushToArray(
      values,
      stringify(value, keyPrefix, commaRoundTrip, valueSideChannel, options),
    );
  }
  return values;
};
const compact = (value) => {
  const refs = [];
  const queue = [{ obj: { o: value }, prop: 'o' }];
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const obj = item.obj[item.prop];
    const keys = Object.keys(obj);
    for (let j = 0; j < keys.length; j++) {
      const key = keys[j];
      const val = obj[key];
      if (isObject(val) && refs.indexOf(val) === -1) {
        queue.push({ obj: obj, prop: key });
        refs.push(val);
      }
    }
  }
  while (queue.length > 1) {
    const item = queue.pop();
    const obj = item.obj[item.prop];
    if (isArray(obj)) {
      const compacted = [];
      for (let j = 0; j < obj.length; j++) {
        if (typeof obj[j] !== 'undefined') {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
  return value;
};
const mg = (target, source) => {
  if (!source) return target;
  if (typeof source !== 'object') {
    if (isArray(target)) {
      target.push(source);
    } else if (target && typeof target === 'object') {
      if (!hasOwn(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== 'object') {
    return [target].concat(source);
  }
  let mergeTarget = target;
  if (isArray(target) && !isArray(source)) {
    const obj = {};
    for (let i = 0; i < target.length; i++) {
      if (typeof target[i] !== 'undefined') {
        obj[i] = target[i];
      }
    }
    mergeTarget = obj;
  }
  if (isArray(target) && isArray(source)) {
    source.forEach((item, i) => {
      if (hasOwn(target, i)) {
        const targetItem = target[i];
        if (isObject(targetItem) && isObject(item)) {
          target[i] = mg(targetItem, item);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce((acc, key) => {
    const value = source[key];
    acc[key] = hasOwn(acc, key) ? mg(acc[key], value) : value;
    return acc;
  }, mergeTarget);
};
const parseArray = (s, options) =>
  s && typeof s === 'string' && options.comma && s.indexOf(',') > -1
    ? s.split(',')
    : s;
const parseObject = (chain, leaf, options) => {
  for (let i = chain.length - 1; i >= 0; i--) {
    let obj;
    const root = chain[i];
    if (root === '[]') {
      obj = leaf === '' ? [] : [].concat(leaf);
    } else {
      obj = {};
      const cleanRoot =
        root.charAt(0) === '[' && root.charAt(root.length - 1) === ']'
          ? root.slice(1, -1)
          : root;
      const index = parseInt(cleanRoot, 10);
      if (
        !Number.isNaN(index) &&
        root !== cleanRoot &&
        String(index) === cleanRoot &&
        index >= 0 &&
        index <= options.arrayLimit
      ) {
        obj = [];
        obj[index] = leaf;
      } else if (cleanRoot !== '__proto__') {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
const parseKeys = (key, val, options) => {
  if (!key) return;
  const keys = [];
  const brackets = /(\[[^[\]]*])/;
  const child = /(\[[^[\]]*])/g;
  let segment = brackets.exec(key);
  const parent = segment ? key.slice(0, segment.index) : key;
  if (parent) {
    if (hasOwn(Object.prototype, parent)) return;
    keys.push(parent);
  }
  let i = 0;
  while ((segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (hasOwn(Object.prototype, segment[1].slice(1, -1))) {
      return;
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push('[' + key.slice(segment.index) + ']');
  }
  return parseObject(keys, val, options);
};
const parse = (s, options) => {
  s = s.replace(/^\?/, '');
  const parts = s.split('&');
  const res = Object.create(null);
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    let key;
    let val;
    let pos = part.indexOf(']=');
    pos = pos === -1 ? part.indexOf('=') : pos + 1;
    if (pos === -1) {
      key = decode(part);
      val = '';
    } else {
      key = decode(part.slice(0, pos));
      const arr = parseArray(part.slice(pos + 1), options);
      val = isArray(arr) ? arr.map(decode) : decode(arr);
    }
    if (part.indexOf('[]=') > -1) val = isArray(val) ? [val] : val;
    res[key] = hasOwn(res, key) ? [].concat(res[key], val) : val;
  }
  return res;
};
// https://github.com/ljharb/qs/blob/main/lib/parse.js
const qsParse = (s, options) => {
  if (!s || typeof s !== 'string') return {};
  options = Object.assign({}, defaultParseOptions, options);
  let obj = {};
  const tempObj = parse(s, options);
  const keys = Object.keys(tempObj);
  for (let i = 0; i < keys.length; i++) {
    const newObj = parseKeys(keys[i], tempObj[keys[i]], options);
    obj = mg(obj, newObj);
  }
  return options.allowSparse ? obj : compact(obj);
};
// https://github.com/ljharb/qs/blob/main/lib/stringify.js
const qsStringify = (obj, options) => {
  if (!isObject(obj)) return '';
  options = Object.assign({}, defaultStringifyOptions, options);
  const keys = [];
  const objKeys = Object.keys(obj);
  const sideChannel = new WeakMap();
  const commaRoundTrip = Boolean(
    options.arrayFormat === 'comma' && options.commaRoundTrip,
  );
  for (let i = 0; i < objKeys.length; ++i) {
    const key = objKeys[i];
    pushToArray(
      keys,
      stringify(obj[key], key, commaRoundTrip, sideChannel, options),
    );
  }
  const res = keys.join('&');
  if (res.length === 0) return '';
  return options.addQueryPrefix ? `?${res}` : res;
};

const colors = {
  red: '#FF4136',
  navy: '#001F3F',
  blue: '#0074D9',
  aqua: '#7FDBFF',
  teal: '#39CCCC',
  lime: '#01FF70',
  gray: '#AAAAAA',
  black: '#111111',
  olive: '#3D9970',
  white: '#FFFFFF',
  green: '#2ECC40',
  yellow: '#FFDC00',
  orange: '#FF851B',
  purple: '#B10DC9',
  maroon: '#85144B',
  silver: '#DDDDDD',
  fuchsia: '#F012BE',
};
// https://github.com/Qix-/color-convert/blob/master/conversions.js
const rgbToHsl = (rgb) => {
  let h;
  let s;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const a = rgb[3];
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) h += 360;
  const l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  const hsl = [h, s * 100, l * 100];
  if (typeof a === 'number') hsl.push(a);
  return hsl;
};
const rgbToHex = (rgb) => {
  const string = (
    ((Math.round(rgb[0]) & 0xff) << 16) +
    ((Math.round(rgb[1]) & 0xff) << 8) +
    (Math.round(rgb[2]) & 0xff)
  )
    .toString(16)
    .toUpperCase();
  let hex = '000000'.substring(string.length) + string;
  if (typeof rgb[3] === 'number') {
    hex += Math.round(rgb[3] * 0xff).toString(16);
  }
  return hex;
};
/**
 * Not supported on `alpha`
 */
const rgbToAnsi256 = (rgb) => {
  const r = rgb[0];
  const g = rgb[1];
  const b = rgb[2];
  // We use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.
  if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
    if (r < 8) return 16;
    if (r > 248) return 231;
    return Math.round(((r - 8) / 247) * 24) + 232;
  }
  return (
    16 +
    36 * Math.round((r / 255) * 5) +
    6 * Math.round((g / 255) * 5) +
    Math.round((b / 255) * 5)
  );
};
const hslToRgb = (hsl) => {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  const a = hsl[3];
  let t2;
  let t3;
  let val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    t3 = h + (1 / 3) * -(i - 1);
    if (t3 < 0) t3++;
    if (t3 > 1) t3--;
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  if (typeof a === 'number') rgb.push(a);
  return rgb;
};
const hexToRgb = (hex) => {
  const match = hex.match(/[a-f0-9]{8}|[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) return [0, 0, 0];
  let colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString
      .split('')
      .map((char) => char + char)
      .join('');
  }
  let a;
  if (colorString.length === 8) {
    a = Number(BigInt('0x' + colorString[6] + colorString[7])) / 0xff;
    colorString = colorString.slice(0, 6);
  }
  const integer = Number(BigInt('0x' + colorString));
  const rgb = [(integer >> 16) & 0xff, (integer >> 8) & 0xff, integer & 0xff];
  if (a) rgb.push(a);
  return rgb;
};
const ansi256ToRgb = (val) => {
  if (val >= 232) {
    const c = (val - 232) * 10 + 8;
    return [c, c, c];
  }
  val -= 16;
  let rem;
  const r = (Math.floor(val / 36) / 5) * 255;
  const g = (Math.floor((rem = val % 36) / 6) / 5) * 255;
  const b = ((rem % 6) / 5) * 255;
  return [r, g, b];
};
function randomColor(type) {
  const r = random(255);
  const g = random(255);
  const b = random(255);
  const color = [r, g, b];
  if (type === 'hex') return rgbToHex(color);
  if (type === 'hsl') return rgbToHsl(color);
  if (type === 'ansi256') return rgbToAnsi256(color);
  return color;
}

const noop = () => {};
// TypeScript cannot use arrowFunctions for assertions.
function assert(condition, error) {
  if (!condition) throw new Error(error);
}
// Because there is access to the global object,
// it is declared as a function here for better `tree-shaking`.
const raf = (fn) => {
  typeof requestAnimationFrame === 'function'
    ? requestAnimationFrame(fn)
    : typeof process !== 'undefined' && typeof process.nextTick === 'function'
    ? process.nextTick(fn)
    : setTimeout(fn, 17);
};
const now = () =>
  typeof performance !== 'undefined' && typeof performance.now === 'function'
    ? performance.now()
    : Date.now();
const idleCallback =
  typeof requestIdleCallback !== 'undefined' ? requestIdleCallback : raf;
const last = (arr, i = 0) => {
  return arr[arr.length + i - 1];
};
const uniq = (arr) => {
  return Array.from(new Set(arr));
};
const hasOwn = (obj, key) => {
  return Object.hasOwnProperty.call(obj, key);
};
const capitalize = ([v, ...args]) => {
  return v.toUpperCase() + args.join('').toLowerCase();
};
const slash = (val) => {
  return val.replace(/\\/g, '/');
};
const makeMap = (arr) => {
  const map = Object.create(null);
  for (let i = 0; i < arr.length; i++) {
    map[arr[i]] = true;
  }
  return (v) => Boolean(map[v]);
};
const decimalPlaces = (n) =>
  !Number.isFinite(n) || Number.isInteger(n)
    ? 0
    : String(n).split('.')[1].length;
const random = (min = 0, max = 0) => {
  if (max === min) return max;
  if (max < min) min = [max, (max = min)][0];
  const n = Number(
    (Math.random() * (max - min) + min).toFixed(
      Math.max(decimalPlaces(min), decimalPlaces(max)),
    ),
  );
  if (n > max) return max;
  if (n < min) return min;
  return n;
};
const once = (fn) => {
  let result;
  let called = false;
  function wrap(...args) {
    if (called) return result;
    called = true;
    result = fn.apply(this, args);
    return result;
  }
  return wrap;
};
const sleep = (t) => {
  return new Promise((resolve) => {
    if (!t) return resolve();
    let timer;
    timer = setTimeout(() => {
      timer && clearTimeout(timer);
      timer = null;
      resolve();
    }, t);
  });
};
const remove = (arr, el) => {
  if (isArray(arr)) {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
      return true;
    }
    return false;
  } else {
    if (arr.has(el)) {
      arr.delete(el);
      return true;
    }
    return false;
  }
};
// prettier-ignore
function map(data, fn) {
    fn = fn || ((val) => val);
    if (isArray(data)) {
        return data.map((val, i) => fn(val, i));
    }
    if (isSet(data)) {
        const cloned = new Set();
        for (const val of data) {
            cloned.add(fn(val));
        }
        return cloned;
    }
    if (isPlainObject(data)) {
        const cloned = {};
        for (const key in data) {
            cloned[key] = fn(data[key], key);
        }
        return cloned;
    }
    throw new Error(`Invalid type "${toRawType(data)}"`);
}
const toCamelCase = (val, upper = false, reg = /[_-]/g) => {
  return val
    .split(reg)
    .map((k, i) => {
      if (!k) return null;
      return !upper && i === 0
        ? k.toLowerCase()
        : k.charAt(0).toUpperCase() + k.slice(1).toLowerCase();
    })
    .join('');
};
const getExtname = (p) => {
  let extra = '';
  if (isAbsolute(p)) {
    p = new URL(p).pathname;
  }
  let len = p.length;
  while (~--len) {
    const c = p[len];
    if (c === '/') return '';
    if (c === '.') return c + extra;
    extra = c + extra;
  }
  return '';
};
// From `iterator interface` of simulate
const FAUX_ITERATOR_SYMBOL = '@@iterator';
const ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
const getIteratorFn = (v) => {
  let res;
  if (v) {
    res = (ITERATOR_SYMBOL && v[ITERATOR_SYMBOL]) || v[FAUX_ITERATOR_SYMBOL];
  }
  return res;
};
const sortStrings = (arr, locales = 'en') => {
  return [...arr].sort((a, b) => a.localeCompare(b, locales));
};
// If there is a deep sort, the user can handle it by themselves
const sortKeys = (val, locales) => {
  const map = {};
  const keys = sortStrings(Object.keys(val), locales);
  for (const key of keys) {
    map[key] = val[key];
  }
  return map;
};
const clearUndef = (val) => {
  Object.keys(val).forEach((key) => {
    if (val[key] === undefined) {
      delete val[key];
    }
  });
  return val;
};
const pick = (val, keys, omitUndefined = false) => {
  return keys.reduce((n, k) => {
    if (k in val) {
      if (!omitUndefined || val[k] !== undefined) {
        n[k] = val[k];
      }
    }
    return n;
  }, {});
};
const omit = (val, keys) => {
  return Object.keys(val).reduce((n, k) => {
    if (!keys.includes(k)) {
      n[k] = val[k];
    }
    return n;
  }, {});
};
const _reFullWs = /^\s*$/;
const unindent = (str) => {
  const lines = (typeof str === 'string' ? str : str[0]).split('\n');
  const whitespaceLines = lines.map((line) => _reFullWs.test(line));
  const commonIndent = lines.reduce((min, line, idx) => {
    if (whitespaceLines[idx]) return min;
    const indent = line.match(/^\s*/)?.[0].length;
    return indent === undefined ? min : Math.min(min, indent);
  }, Number.POSITIVE_INFINITY);
  let emptyLinesHead = 0;
  while (emptyLinesHead < lines.length && whitespaceLines[emptyLinesHead]) {
    emptyLinesHead++;
  }
  let emptyLinesTail = 0;
  while (
    emptyLinesTail < lines.length &&
    whitespaceLines[lines.length - emptyLinesTail - 1]
  ) {
    emptyLinesTail++;
  }
  return lines
    .slice(emptyLinesHead, lines.length - emptyLinesTail)
    .map((line) => line.slice(commonIndent))
    .join('\n');
};
const deferred = () => {
  let reject;
  let resolve;
  const promise = new Promise((rs, rj) => {
    reject = rj;
    resolve = rs;
  });
  return { promise, resolve, reject };
};
const batchProcess = ({ ms, processor }) => {
  const queue = [];
  const flush = () => {
    setTimeout(() => {
      const ls = [];
      const fns = [];
      for (const { value, resolve } of queue) {
        ls.push(value);
        fns.push(resolve);
      }
      queue.length = 0;
      processor(ls);
      for (const fn of fns) {
        fn();
      }
    }, ms || 0);
  };
  return (value) => {
    const defer = deferred();
    if (queue.length === 0) flush();
    queue.push({ value, resolve: defer.resolve });
    return defer.promise;
  };
};
const retry = (fn, callback) => {
  let n = 0;
  if (typeof callback === 'number') {
    const max = callback;
    callback = (e, n, next) => (n > max ? Promise.reject(e) : next());
  }
  const next = () => {
    try {
      n++;
      const res = fn();
      return Promise.resolve(res).catch((e) => callback(e, n, next));
    } catch (e) {
      return callback(e, n, next);
    }
  };
  return next();
};

exports.Queue = smallQueue.Queue;
exports.ansi256ToRgb = ansi256ToRgb;
exports.assert = assert;
exports.batchProcess = batchProcess;
exports.capitalize = capitalize;
exports.clearUndef = clearUndef;
exports.clone = clone$1;
exports.colors = colors;
exports.createCacheObject = createCacheObject;
exports.createJSONParse = createJSONParse;
exports.createJSONStringify = createJSONStringify;
exports.debounce = debounce;
exports.decimalPlaces = decimalPlaces;
exports.deferred = deferred;
exports.exec = exec;
exports.getExtname = getExtname;
exports.getIteratorFn = getIteratorFn;
exports.hasOwn = hasOwn;
exports.hexToRgb = hexToRgb;
exports.hslToRgb = hslToRgb;
exports.idleCallback = idleCallback;
exports.inlineString = inlineString;
exports.isAbsolute = isAbsolute;
exports.isArray = isArray;
exports.isBase64 = isBase64;
exports.isBrowser = isBrowser;
exports.isBuffer = isBuffer;
exports.isByteLength = isByteLength;
exports.isCNPhone = isCNPhone;
exports.isDate = isDate;
exports.isDomain = isDomain;
exports.isEmail = isEmail;
exports.isEmptyObject = isEmptyObject;
exports.isFunction = isFunction;
exports.isIP = isIP;
exports.isInBounds = isInBounds;
exports.isMap = isMap;
exports.isNil = isNil;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPhone = isPhone;
exports.isPlainObject = isPlainObject;
exports.isPort = isPort;
exports.isPrimitiveValue = isPrimitiveValue;
exports.isPromise = isPromise;
exports.isPromiseLike = isPromiseLike;
exports.isRegExp = isRegExp;
exports.isSet = isSet;
exports.isString = isString;
exports.isTypedArray = isTypedArray;
exports.isWeakMap = isWeakMap;
exports.isWeakSet = isWeakSet;
exports.isWhitespace = isWhitespace;
exports.isWindow = isWindow;
exports.jsonParse = jsonParse;
exports.jsonStringify = jsonStringify;
exports.last = last;
exports.loopSlice = loopSlice;
exports.makeMap = makeMap;
exports.map = map;
exports.mathExprEvaluate = mathExprEvaluate;
exports.merge = merge;
exports.noop = noop;
exports.now = now;
exports.omit = omit;
exports.once = once;
exports.pick = pick;
exports.qsParse = qsParse;
exports.qsStringify = qsStringify;
exports.raf = raf;
exports.random = random;
exports.randomColor = randomColor;
exports.remove = remove;
exports.retry = retry;
exports.rgbToAnsi256 = rgbToAnsi256;
exports.rgbToHex = rgbToHex;
exports.rgbToHsl = rgbToHsl;
exports.root = root;
exports.slash = slash;
exports.sleep = sleep;
exports.sortKeys = sortKeys;
exports.sortStrings = sortStrings;
exports.supportWasm = supportWasm;
exports.throttle = throttle;
exports.toCamelCase = toCamelCase;
exports.toRawType = toRawType;
exports.unindent = unindent;
exports.uniq = uniq;
exports.uuid = uuid;
