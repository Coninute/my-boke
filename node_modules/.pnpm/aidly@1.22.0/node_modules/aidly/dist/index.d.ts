import type { Prettify } from './types';
export { Queue } from 'small-queue';
export { root } from './root';
export { uuid } from './uuid';
export { clone } from './clone';
export { merge } from './merge';
export { loopSlice } from './loopSlice';
export { throttle, debounce } from './throttle';
export { createCacheObject, type CacheUnit } from './cache';
export { exec, inlineString, type ExecOptions } from './exec';
export {
  mathExprEvaluate,
  type MathExprEvaluateOptions,
} from './mathExprEvaluate';
export {
  isNil,
  isNumber,
  isString,
  isArray,
  isObject,
  isPlainObject,
  isFunction,
  isAbsolute,
  isMap,
  isWeakMap,
  isSet,
  isWeakSet,
  isDate,
  isRegExp,
  isBuffer,
  isTypedArray,
  isPromise,
  isPromiseLike,
  isBase64,
  isIP,
  isPort,
  isDomain,
  isEmail,
  isPhone,
  isCNPhone,
  isByteLength,
  isWindow,
  isBrowser,
  isInBounds,
  isWhitespace,
  isEmptyObject,
  isPrimitiveValue,
  toRawType,
  supportWasm,
} from './is';
export {
  jsonParse,
  jsonStringify,
  createJSONParse,
  createJSONStringify,
} from './json';
export {
  qsParse,
  qsStringify,
  type QsParseOptions,
  type QsStringifyOptions,
} from './qs';
export {
  rgbToHsl,
  rgbToHex,
  rgbToAnsi256,
  hslToRgb,
  hexToRgb,
  ansi256ToRgb,
  colors,
  randomColor,
} from './color';
export type {
  Nullable,
  Awaitable,
  Arrayable,
  ElementOf,
  TypedArray,
  PrimitiveType,
  PhoneLocales,
  Prettify,
  DeepPrettify,
  Protocols,
  ExtractRouteParams,
} from './types';
export declare const noop: () => void;
export declare function assert(
  condition: unknown,
  error?: string,
): asserts condition;
export declare const raf: (fn: (...args: Array<any>) => any) => void;
export declare const now: () => number;
export declare const idleCallback:
  | ((fn: (...args: Array<any>) => any) => void)
  | typeof requestIdleCallback;
export declare const last: <T>(arr: Array<T>, i?: number) => T;
export declare const uniq: <T>(arr: Array<T>) => Array<T>;
export declare const hasOwn: <T extends unknown>(
  obj: T,
  key: PropertyKey,
) => boolean;
export declare const capitalize: ([v, ...args]: string) => string;
export declare const slash: (val: string) => string;
export declare const makeMap: <T extends string>(
  arr: Array<T>,
) => (v: T) => boolean;
export declare const decimalPlaces: (n: number) => number;
export declare const random: (min?: number, max?: number) => number;
export declare const once: <T extends (...args: Array<any>) => any>(fn: T) => T;
export declare const sleep: (t: number) => Promise<void>;
export declare const remove: <T>(arr: Array<T> | Set<T>, el: T) => boolean;
export declare function map<T, U>(data: Set<T>, fn?: (val: T) => U): Set<U>;
export declare function map<T, U>(
  data: Array<T>,
  fn?: (val: T, i: number) => U,
): Array<U>;
export declare function map<T, U>(
  data: T,
  fn?: (val: T[keyof T], key: keyof T) => U,
): Prettify<Record<keyof T, U>>;
export declare const toCamelCase: (
  val: string,
  upper?: boolean,
  reg?: RegExp,
) => string;
export declare const getExtname: (p: string) => string;
export declare const getIteratorFn: <T, K = typeof Symbol.iterator>(
  v: T,
) => K extends keyof T ? T[K] : unknown;
export declare const sortStrings: (
  arr: Array<string>,
  locales?: string,
) => string[];
export declare const sortKeys: <T extends Record<PropertyKey, unknown>>(
  val: T,
  locales?: string,
) => T;
export declare const clearUndef: <T extends object>(val: T) => T;
export declare const pick: <O extends object, T extends keyof O>(
  val: O,
  keys: Array<T>,
  omitUndefined?: boolean,
) => Pick<O, T> extends infer T_1 ? { [K in keyof T_1]: Pick<O, T>[K] } : never;
export declare const omit: <O extends object, T extends keyof O>(
  val: O,
  keys: Array<T>,
) => Omit<O, T> extends infer T_1 ? { [K in keyof T_1]: Omit<O, T>[K] } : never;
export declare const unindent: (str: TemplateStringsArray | string) => string;
export declare const deferred: <T = void>() => {
  promise: Promise<T>;
  resolve: (value: T | PromiseLike<T>) => void;
  reject: (reason?: any) => void;
};
export declare const batchProcess: <T = unknown>({
  ms,
  processor,
}: {
  ms?: number;
  processor: (queue: Array<T>) => void;
}) => (value: T) => Promise<void>;
export declare const retry: <T>(
  fn: () => T,
  callback:
    | number
    | ((
        e: unknown | null,
        n: number,
        next: () => Promise<Awaited<T>>,
      ) => Promise<Awaited<T>>),
) => Promise<Awaited<T>>;
